{"meta":{"title":"筆跡","subtitle":"","description":"","author":"阿刚","url":"https://luomit.github.io","root":"/"},"pages":[{"title":"","date":"2021-05-12T07:29:26.111Z","updated":"2020-10-24T03:57:36.876Z","comments":true,"path":"未完待續/Blender材质基础(一).html","permalink":"https://luomit.github.io/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BA%8C/Blender%E6%9D%90%E8%B4%A8%E5%9F%BA%E7%A1%80(%E4%B8%80).html","excerpt":"","text":""},{"title":"about","date":"2020-12-09T15:28:54.000Z","updated":"2021-05-12T07:40:15.229Z","comments":true,"path":"about/index.html","permalink":"https://luomit.github.io/about/index.html","excerpt":"","text":""},{"title":"Archives","date":"2020-12-12T11:11:04.000Z","updated":"2021-05-12T07:38:56.574Z","comments":true,"path":"archives/index.html","permalink":"https://luomit.github.io/archives/index.html","excerpt":"","text":""},{"title":"about me","date":"2020-12-09T15:28:54.000Z","updated":"2021-05-12T08:26:11.938Z","comments":true,"path":"about me/index.html","permalink":"https://luomit.github.io/about%20me/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-12T10:18:10.000Z","updated":"2021-05-12T14:54:09.603Z","comments":true,"path":"categories/index.html","permalink":"https://luomit.github.io/categories/index.html","excerpt":"","text":""},{"title":"diary","date":"2020-12-09T15:28:54.000Z","updated":"2021-05-12T08:25:43.850Z","comments":true,"path":"diary/index.html","permalink":"https://luomit.github.io/diary/index.html","excerpt":"","text":""},{"title":"Friends","date":"2020-12-12T11:11:04.000Z","updated":"2021-05-11T15:43:15.156Z","comments":true,"path":"friends/index.html","permalink":"https://luomit.github.io/friends/index.html","excerpt":"","text":""},{"title":"gallery","date":"2020-12-09T15:28:54.000Z","updated":"2021-05-12T08:25:02.100Z","comments":true,"path":"gallery/index.html","permalink":"https://luomit.github.io/gallery/index.html","excerpt":"","text":""},{"title":"prjects","date":"2021-05-12T07:51:07.000Z","updated":"2021-05-12T08:11:22.503Z","comments":true,"path":"projects/index.html","permalink":"https://luomit.github.io/projects/index.html","excerpt":"","text":""},{"title":"","date":"2021-05-12T09:11:05.394Z","updated":"2021-05-12T09:11:05.394Z","comments":true,"path":"search/index.html","permalink":"https://luomit.github.io/search/index.html","excerpt":"","text":""},{"title":"schedule","date":"2020-12-09T15:35:38.000Z","updated":"2020-12-09T15:35:38.757Z","comments":true,"path":"schedule/index.html","permalink":"https://luomit.github.io/schedule/index.html","excerpt":"","text":""},{"title":"Tag","date":"2020-12-12T11:11:04.000Z","updated":"2020-12-13T07:14:23.619Z","comments":true,"path":"tags/index.html","permalink":"https://luomit.github.io/tags/index.html","excerpt":"","text":""},{"title":"CSS基础","date":"2020-02-25T04:06:44.000Z","updated":"2021-05-12T09:41:17.591Z","comments":true,"path":"未完待續/CSS基础.html","permalink":"https://luomit.github.io/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BA%8C/CSS%E5%9F%BA%E7%A1%80.html","excerpt":"","text":"CSS介绍层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML(标准通用标记语言的一个应用)或XML(便准通用标记语言的一个子集)等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态的对网页各元素进行格式化。CSS能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体号样式，拥有对网页对象模型样式编辑的能力。 CSS基础语法css语法说明每个CSS样式由两部分组成，即选择符和声明，而声名又分为属性和属性值两部分；属性需放在花括号中，属性与属性值用冒号隔开，每条声明用分号结束；当一个声名中有多个属性和属性值时，属性和属性不分先后顺序；在书写样式的过程中，空格、换行等操作不影响显示；例如：idv{width:200px; height:200px; background:red;} 样式的建立和使用方法内部样式表、外部样式表和内联样式表 内部样式表(嵌套到页面中)语法： 123&lt;style type=&quot;text/css&quot;&gt; css语句&lt;/style&gt; 注：使用style标记创建样式时，最好将该标记写在内； 外部样式表外部样式表的两种方式a.外部样式表的创建b.外部样式表的导入 方法一: 语法: 说明：使用link元素导入外部样式表时，需要将该元素写在文档头部，即内； rel：用于定义文档关联，表示关联样式表； type：定义文档类型； 方法二： 语法： @import url(“目标文件的路径以及文件名全称”)； 说明：@和import之间没有空格，url和小括号之间也没有空格；括号内加双引号，结尾必须以分号结束； link和import的区别(1)来源不同：link属于html标签，而@import完全是CSS提供的一种方式。link标签除了可以加载CSS外，还可以做很多其他的事情，比如定义RSS，定义rel连接属性，@import只能加载CSS；(2)加载顺序：当一个网页在加载时(就是被浏览者浏览的时候)，link引入的CSS会与html内容同时被加载，而@import引用的CSS会等到html内容全部加载完成再加载；这就导致页面在一开始加载时丢失样式，内容混乱；(3)兼容性：@import时CSS2.1提出的，所以老的浏览器不支持，@import只在IE5以上版本的浏览器才能识别，而link标签没有这个问题；(4)dom控制样式：当使用JavaScript控制dom去改变样式时，只能使用link标签来引用CSS，因为@import不支持dom的样式控制方法； 内联样式表(表行间样式，内行样式，嵌入式样式)语法：&lt;标签 style=”属性:属性值;属性:属性值;”&gt;&lt;/标签&gt;例如： 样式表的优先级内联样式表在页面中优先级高于内部样式表和外部样式表;外部样式表和内部样式表的优先级取决于两者在页面中书写的先后顺序； CSS选择器(选择符)选择符的定义： 选择符表示要定义的对象，可以是元素本身，也可以是一类元素或者制定名称的元素。常用的选择符有十多种类型，id选择符，class选择符，通配符，群组选择符，包含选择符，伪类选择符，伪对象选择符。 元素选择符/类型选择符/标签选择符(element选择器)语法：元素名称{属性:属性值;}类型选择符是根据html语言中的标记来直接定义 说明： a.元素选择符就是以文档语言对象类型作为选择符，即使用结构中元素名称作为选择符；例如body、div、p、img、strong、span等。 b.所有的页面元素都可以作为选择符；用法： (1)如果想改变某个元素的默认样式时，可以使用类型选择符；(如：改变一个p段落样式) (2)当想要统一文档某个元素的显示效果时，可以使用类型选择符；(改变文档所有p段落样式) id选择器语法：#id名{属性:属性值;}说明：(1)当我们使用id选择符时，应该为每个元素定义一个id属性；如：(2)id选择器的语法格式是”#”加上自定义的id名；如：#box{width:300px;height:500px;}(3)取名时要取英文名，不能取关键字：(所有的标记和属性都是关键字)(4)一个id名称只能对应文档中一个具体的元素对象，因为id只能定义页面中某一个唯一的元素对象。(5)最大的用处：创建网页的外部结构 class选择器语法：.class名{属性:属性值;}说明： 当我们使用类型选择符时，应该先为每一个元素定义一个类名称，类选择符的语法格式如：用法： class选择符更适合定义一种类型样式； 群组选择器语法：选择符1,选择符2,选择符3….{属性:属性值;}说明：当有多个选择符应用相同的样式时，可以将选择符用”,”分隔的方式，合并为一组实例：.top,#nav,p{width:100px;} 包含选择器语法：选择符1(父) 选择符2(子){属性:属性值;}说明：选择符1和选择符2用空格隔开，含义就是选择符1包含所有选择符2；实例：div ul li{height:25px;} 通配符语法：*{属性:属性值;}说明：通配选择符的写法是”*”,其含义是所有元素用法：常用来重置样式 伪类选择器a:link{color:red;} 未访问的连接状态a:visited{color:green;} 已访问的连接状态a:hover{color:blue;} 鼠标滑过时的连接状态a:avtive{color:yellow;} 鼠标点击时的连接状态说明： (1)当这四类超链接伪类选择符联合使用时，应注意他们的顺序，正常的顺序为：a,a:link,a:visited,a:hover,a:active,错误的顺序有时会使超链接的样式失效； (2)为了简化代码，可以把伪类选择符中相同的声名提出来放在a选择符中；例如：a{color:red;} a:hover{color:green;}表示超链接的三种状态都相同，只有鼠标划过变化颜色。 常用于超链接 转载符的权重css中用四位数表示权重，权重的表达法方式如：0,0,0,0类型选择符的权重为0001 a p div span form … 1class选择符的权重为0010 .class 10id选择符的权重为0100 # 100子选择符的权重为0000属性选择符的权重为0010伪类选择符的权重为0010伪元素选择符的权重为0010包含选择符的权重：为包含选择符的权重之和内联样式的权重为1000继承样式的权重为1000注：如果权重相同时，则执行后写的样式； html与css的注释html的注释css的注释/–注释的内容–/","author":"luomit"},{"title":"HTML5基础入门","date":"2020-02-24T04:06:44.000Z","updated":"2021-05-12T09:41:09.793Z","comments":true,"path":"未完待續/HTML5.html","permalink":"https://luomit.github.io/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BA%8C/HTML5.html","excerpt":"","text":"HTML的基本格式12345678910&lt;!DOCTYPE html&gt; &lt;!---命名文档类型HTML5---&gt;&lt;html lang=&quot;en&quot;&gt; &lt;!---说明我们写的是标记语言HTML文档---&gt;&lt;head&gt; &lt;!---头部文件(描述区)---&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!---编码格式utf-8、gb2312、gbk---&gt; &lt;title&gt;Title&lt;/title&gt; &lt;!---网页标题---&gt;&lt;/head&gt;&lt;body&gt; &lt;!---命网页主体---&gt;&lt;/body&gt;&lt;/html&gt; HTML5的基本语法HTML5标记的语法常规标记 &lt;标记名称 属性1名=”属性1值” 属性2名=”属性2值” ……&gt;&lt;/标记名称&gt; 空标记 &lt;标记名称 属性1名=”属性1值”/&gt;标记有两种形式，我们分别称它们为单标记和双标记或者空标记和普通标记;说明： (1)写在&lt;&gt;括号里的第一个单词，叫做标记，也叫标签，也称做元素； (2)标记和属性用空格隔开，属性和属性值用等号相连接，属性值必须用双引号括起来； (3)一个标记可以有多个属性，属性和属性之间用空格隔开，属性不分先后顺序； (4)空标记是指没有结束标签的标记，必须使用”/“来关闭，例如:; HTML5常用标签标题标签 123456&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h4&gt;&lt;/h4&gt;&lt;h5&gt;&lt;/h5&gt;&lt;h6&gt;&lt;/h6&gt; 标题标签共有六级，一级字体最大； 字体标签 段落标签，标识一个段落(默认情况下段落与段落之间有段间距) 这两个标签都是使字体倾斜，一般情况下推荐使用标签 设置文本加粗效果的标签，一般情况下推荐使用标签，语义明确 设置文本下划线的标签 空标签，换行标签 空标签，水平线标签 字符实体(转义字符) 空格 &gt;右尖括号 &lt;左尖括号 备案中图标 HTML5列表HTML中有三种列表，分别是：无序列表，有序列表，自定义列表 无序列表12345&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表12345&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 有序列表的属性(1)type 规定列表中的列表项目的项目符号的类型语法： 1234567&lt;ol type=&quot;A&quot;&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol type=&quot;I&quot;&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 1 数字的有序列表默认有(1，2，3，4)a 字母顺序的有序列表有(a,b,c,d)A 大写字母的有序列表有(A,B,C,D)i 罗马数字小写(i,ii,iii,iv)IVI 罗马数字大写(I，II，III，) (2)start 属性规定有序列表的开始点语法: 12345&lt;ol start=&quot;5&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 自定义列表1234&lt;dl&gt; &lt;dt&gt;名词&lt;/dt&gt; &lt;dd&gt;解释&lt;/dd&gt; &lt;!---definition description 定义描述---&gt;&lt;/dl&gt; HTML5超链接和图像超链接语法： 链接文本或图片空连接 说明：href部分中url后边跟的是链接页面的地址(包含文件名) title属性，当加入title属性是鼠标指针在这个对象上会显示title的内容；target 属性定义了打开链接的目标窗口；_blank 在新的浏览器标签页上打开一个新的窗口(保留原始页面)；_self 在当前浏览器标签页打开新的跳转窗口，此为默认； 图像语法： 说明：属性src表示图片的来源(图像的存放路径)；border属性标识了图像的面框；width和height设定图像在页面上显示的宽高；title这是当鼠标悬停在图片上时要显示的信息；alt当图片不能正确显示的时候，可以用作提示的信息给用的属性，这样用户体验也许会好些； 文件的相对路径与绝对路径相对路径相对路径的写法：(同级)当文件目录与目标目录在同一文件夹下时，直接书写文件名+文件后缀(上级找下级)当当前文件夹和目标文件所处的文件夹在同一路径下时，目标文件夹名/目标文件全称+目标文件后缀(下级找上级)当当前文件所处的文件夹和目标文件在同一目录时，使用../将当前文件跳转到上一级别目录同级文职再+目标文件名+目标文件后缀；例如../images/a01.jpg 绝对路径例如: HTML5常用元素快标签语法：说明：没有具体含义，统称为快标签，用来设置文档区域，是文档布局常用对象 语法：说明：文本结点标签，可以是某一段文字或是某一个字 注释 表格属性说明:注：一对tr表示一行；一对td表示一个单元格(一列) 表的相关属性：(1)width=”表格的宽度”(2)height=”表格的高度”(3)border=”表格的边框”(4)bordercolor=”边框色”(5)cellspacing=”单元格与单元格的间距”(6)cellpadding=”单元格与内容的距离”(7)aligh=”表格的对其方式” 取值：”left”、”center”、”right” (valigh=”垂直对齐”、top、buttom、middle)(8)合并单元格属性:(td) 合并列：colspan”所有要合并的单元格列数” 合并行：rowspan=”所有要合并单元格的行数” 表单元素与属性表单的作用：用来收集用户的信息 表单框 表单控件 语法： 说明： `input：`表即可创建按钮、文本输入框、选择框等各种类型的输入字段 `name：`属性标识表单域的名称 `type：`属性标识表单控件的类型，大概有十多种 `value：`属性定义表单域的默认值，其他属性根据type的不同而有所变化 `maxlength`：控制最多输入的字符数 `size：`控制框的宽度(以字符为单位) (1)文本框(2)密码框(3)提交按钮(4)重置按钮(5)空按钮(6)单选按钮组默认选中(7)复选框组disabled=”disabled”(禁用) checked=”checked”(默认启用) 下拉菜单 语法： 下拉选项1 下拉选项2表单域多行文本定义 语法：说明：多行文本，row属性和cols属性用来设置文本输入窗口的高度和宽度，单位是字符阻止浏览器对窗口的拖到设置：{resize=none;}(这是css属性)","author":"luomit"},{"title":"","date":"2021-05-12T07:29:26.111Z","updated":"2020-10-26T08:21:39.748Z","comments":true,"path":"未完待續/Mermaid基础用法.html","permalink":"https://luomit.github.io/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BA%8C/Mermaid%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95.html","excerpt":"","text":"流程图-基本语法Graphgraph用于定义流程局节点的走线方向；T D或者TB可以让流程图从上往下走。 ```mermaidgraph T D Start –&gt; Stop``` 12graph TD Start --&gt; Stop LR 从左到右 12graph LR Start --&gt; Stop 12graph LR Start --&gt; Stop 流程图方向定义语法： TB从上到下 T D 从上到下(与TB相同) BT 从下到上 RL 从右到左 LR 从左到右 No Des&amp;Shapes默认情况下流程图的节点形状为直角矩形，可通过括号的组合来改变流程图节点的形状 123graph LR A --&gt; B C(A) --&gt; D([Shape]) 123graph LR A --&gt; B C(A) --&gt; D([Shape]) mermai D添加括号改变节点形状时语法也有了些许的改变;添加括号语法后，括号内的内容就是节点里显示的内容且里面必须有内容，括号外面的内容变成了节点形状的name(在一个图表中name不能相同);节点形状语法表|语法|说明||:—–:|:—–:||start[start]|直角矩形||start(start)|圆角矩形||start([start])|体育场形||start[[start]]|长灯光形||start[(start)]|圆柱体形||start((start))|正圆形||start&gt;start]|标签形||start{start}|菱形||start|六角形||start[/start/]|平行四边形||start[\\start]|反向平行四边行||start[/start]|梯形||start[\\start/]|倒梯形| Line&amp;Label节点形状间可以添加各式各样的连线，并且可以在线上添加注释； 12345678910graph TB A --&gt; B C --- D E -- Run! --- F G ---|Run!| H I -.- J K .-&gt; L M -.Run!.-&gt; N O ==Run!==&gt; P Q --Run!--&gt; R --stop!--&gt; S 12345678910graph TB A --&gt; B C --- D E -- Run! --- F G ---|Run!| H I -.- J K .-&gt; L M -.Run!.-&gt; N O &#x3D;&#x3D;Run!&#x3D;&#x3D;&gt; P Q --Run!--&gt; R --stop!--&gt; S 123flowchart TB T--&gt; U &amp; V --&gt; W X &amp; Y --&gt; Z &amp; ZZ 123flowchart TB T--&gt; U &amp; V --&gt; W X &amp; Y --&gt; Z &amp; ZZ Flowchart特殊类型的连线flowchart和graph比连线变得平滑了些许，而且flowchart有更多的连线类型 123456flowchart TB A --o B --x C &amp; D E &amp; F --&gt; G &amp; H I &lt;--&gt; J K x--x L M o--o N 123456flowchart TB A --o B --x C &amp; D E &amp; F --&gt; G &amp; H I &lt;--&gt; J K x--x L M o--o N 较长连线(下面的代码要在8.8以上的mermaid上才能正常运行)123456789101112131415graph TB subgraph one A[A0] --&gt; B&#123;B0&#125; B --&gt;|Yes| C[OK0] C --&gt; D[Rethink0] D --&gt; B B ----&gt; |No| E[End0] end subgraph two F[A1] --&gt; G&#123;B1&#125; G --&gt;|Yes| H[OK1] H--&gt; I[Rethink1] I --&gt; G G -- NO ----&gt; J[End1] end 123456789101112131415graph TD subgraph one A[A0] --&gt; B&#123;B0&#125; B --&gt;|Yes| C[OK0] C --&gt; D[Rethink0] D --&gt; B B ----&gt; |No| E[End0] end subgraph two F[A1] --&gt; G&#123;B1&#125; G --&gt;|Yes| H[OK1] H--&gt; I[Rethink1] I --&gt; G G -- NO ----&gt; J[End1] end 更多线的修饰符:|长度|1|2|3||:—–:|:—–:|:—–:|:—–:||正常|—|—-|—–||普通带箭头|–&gt;|—&gt;|—-&gt;||粗|===|====|=====||粗带箭头|==&gt;|===&gt;|====&gt;||点缀|-.-|-..-|-…-||点缀带箭头|-.-&gt;|-..-&gt;|-…-&gt;| 更加复杂的注释信息在写注释的时候可能会使用到一些符号表情，这些符号表情可能会破坏代码结构，这是可以使用双引号将注释信息转成字符串 12graph LR A--&quot;Run! &amp;&amp; ❤❤ &quot;--&gt;B--&quot;🕒stop!&quot;--&gt;C 12graph LR A--&quot;Run! &amp;&amp; ❤❤ &quot;--&gt;B--&quot;🕒stop!&quot;--&gt;C 转义字符12graph LR A[&quot;A double quote:#quot;&quot;] --&gt;B[&quot;A dec char:#9829;&quot;] 12graph LR A[&quot;A double quote:#quot;&quot;] --&gt;B[&quot;A dec char:#9829;&quot;] 多层嵌套(字图)为流程添加子层subgraph title graph definitionend 1234567891011graph TB c1--&gt;a2 subgraph one a1--&gt;a2 end subgraph two b1--&gt;b2 end subgraph three c1--&gt;c2 end 1234567891011graph TB c1--&gt;a2 subgraph one a1--&gt;a2 end subgraph two b1--&gt;b2 end subgraph three c1--&gt;c2 end 12345graph TB c1--&gt;a2 subgraph ide1 [one] a1--&gt;a2 end 12345graph TB c1--&gt;a2 subgraph ide1 [one] a1--&gt;a2 end 更多有趣的用法官方文档"},{"title":"","date":"2021-05-12T09:29:39.982Z","updated":"2021-05-12T09:29:39.982Z","comments":true,"path":"未完待續/test.html","permalink":"https://luomit.github.io/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BA%8C/test.html","excerpt":"","text":"12345graph TD st--&gt;start op--&gt;operation cond--&gt;condition st--&gt;op--&gt;cond 选项 实例 子层级Kind Assembly BookShelfShelfBookA……BookZ AssembleGroupComponent Group CupsCup0Cup1……Cup10 AssemblyGroupComponent Component Shelf / BookA / Cup1 SubComponent SubComponent BookABook_MeshCup0Cup_BodyCup_Liq 12345graph TB BookShelfd--&gt;Shelfd BookShelfc--&gt;Shelfc BookShelfb--&gt;Shelfb BookShelfa--&gt;Shelfa |||","author":"辣椒炒小鱼干"},{"title":"PFTrack学习笔记","date":"2019-10-10T00:51:04.000Z","updated":"2021-05-12T09:41:06.932Z","comments":true,"path":"未完待續/PFTrack学习笔记.html","permalink":"https://luomit.github.io/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BA%8C/PFTrack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"物体跟踪案例-汽车 快捷键左键 编辑 中键拖拽 缩放视图 右键拖拽 平移视图 设置透视与地平线 节点网络 在进行相机跟踪之前首先要进行素材帧率的匹配、相机焦距的确定、相机高度的调整等；创建Estimate Focal节点然后手动匹配XYZ三个轴来获取当前场景的大概焦距参数；(如下图)相机高度则通过拍摄经验判断，然后填写到EditCamera参数的Y Translate内 跟踪汽车在UserTrack下添加一个AutoTrack来增加跟踪点，因为这里需要跟踪的是汽车，所以可以绘制一个Mask如下； 绘制完成默认紫色的部分为遮挡部分，点击Invert来翻转遮罩，这样就只跟踪汽车了；绘制mask完成后需要跟踪一遍mask；完成mask的跟踪后返回autoTrack节点参数面板(再次点击上图左边Mask大按钮即可返回上一层级)，调整自动跟踪参数，最后执行Ayto-Track； 跟踪修复","author":"luomit"}],"posts":[{"title":"","slug":"筆記/linux/CentOS8.1基础学习","date":"2021-05-12T07:33:42.161Z","updated":"2021-04-28T10:58:02.420Z","comments":true,"path":"2021/05/12/筆記/linux/CentOS8.1基础学习/","link":"","permalink":"https://luomit.github.io/2021/05/12/%E7%AD%86%E8%A8%98/linux/CentOS8.1%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"安装基本命令的使用文本编辑器使用用户权限管理Shell脚本入门常见的服务器Java/Tomcat运行环境的搭建其他软件的编译与安装Redis","categories":[],"tags":[]},{"title":"Unreal Engine 地编技巧合集","slug":"筆記/ue4/Unreal-Engine-地编技巧合集","date":"2021-05-11T12:25:30.000Z","updated":"2021-05-12T09:41:22.800Z","comments":true,"path":"2021/05/11/筆記/ue4/Unreal-Engine-地编技巧合集/","link":"","permalink":"https://luomit.github.io/2021/05/11/%E7%AD%86%E8%A8%98/ue4/Unreal-Engine-%E5%9C%B0%E7%BC%96%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/","excerpt":"","text":"Unreal Engine 使用距离场解决地表贴图重复问题 PixelDepth在UE4中关于深度Depth的函数，PixelDepth像素景深既屏幕像素场景中的深度信息，就是该像素到摄像机的距离。 在游戏场景的制作中，常常需要使用到贴图的高重复度来使得贴图在场景表上有足够的细节；但是由于游戏场景是比较庞大的一个空间，在使用高重复的图时，就无法满足近处与远处的重复值，给得过低无法表现近处贴图材质的节，过高会使得远处有过于明显的贴出重复。 在制作材质时，可以使用PixelDepth获得场景到摄像机的距离，然后使用ler函数将混合两种重复度的贴图，来达到细节表现上贴图重复的平衡。 [练习封装的材质函数] Unreal Engine高效无缝材质衔接场景中模型与模型的交界融合 在材质主节点下有一个Pixel Depth Offset像素深度便宜，创建一个DitherThresholdAA阈值抖动，创建一个常量来与DitherThresholdAA相乘，就可以用这个常量来控制交融的强度范围。 Unreal Engine RVT虚拟纹理使用地表重复纹理物体穿插无缝材质RVT虚拟纹理","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"ue4","slug":"ue4","permalink":"https://luomit.github.io/tags/ue4/"},{"name":"shader","slug":"shader","permalink":"https://luomit.github.io/tags/shader/"},{"name":"地编","slug":"地编","permalink":"https://luomit.github.io/tags/%E5%9C%B0%E7%BC%96/"},{"name":"材质","slug":"材质","permalink":"https://luomit.github.io/tags/%E6%9D%90%E8%B4%A8/"}]},{"title":"Unreal Engine 特效小技巧合集","slug":"筆記/ue4/Unreal-Engine-特效小技巧合集","date":"2021-05-11T12:20:55.000Z","updated":"2021-05-12T09:41:22.277Z","comments":true,"path":"2021/05/11/筆記/ue4/Unreal-Engine-特效小技巧合集/","link":"","permalink":"https://luomit.github.io/2021/05/11/%E7%AD%86%E8%A8%98/ue4/Unreal-Engine-%E7%89%B9%E6%95%88%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/","excerpt":"","text":"透明材质的折射 当要实现折射效果的对象是透明材质对象时，需要取消该对象的的材质属性下的Translucency下的 Render After DOF 选项。 当材质取消Render After DOF 后，镜头远近将影响透明对象的显示，在材质属性Refraction下切换Mode；Index Of Refraction可以等到真实漂亮的折射，Pixel Normal Offset可以纠正相机远近导致材质效果变化较大的问题，但是无法获得折射效果(可能需要配合其他参数实现)。 MeshDeta &amp; GPU粒子类型 使用MeshDeta粒子发射类型时，需要将Mesh下的OverrideMaterial勾选，这样才能给发射的Mesh赋予材质。 当只需要发射一个粒子时，出来需要修改发射率还需要讲Duration的EmitterLoops设置为1，让粒子发射停止循环。","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"ue4","slug":"ue4","permalink":"https://luomit.github.io/tags/ue4/"},{"name":"shader","slug":"shader","permalink":"https://luomit.github.io/tags/shader/"},{"name":"材质","slug":"材质","permalink":"https://luomit.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"vfx","slug":"vfx","permalink":"https://luomit.github.io/tags/vfx/"},{"name":"特效","slug":"特效","permalink":"https://luomit.github.io/tags/%E7%89%B9%E6%95%88/"}]},{"title":"Ureal Engine 小技巧合集","slug":"筆記/ue4/Ureal-Engine-小技巧合集","date":"2021-05-11T09:27:15.000Z","updated":"2021-05-12T09:41:21.653Z","comments":true,"path":"2021/05/11/筆記/ue4/Ureal-Engine-小技巧合集/","link":"","permalink":"https://luomit.github.io/2021/05/11/%E7%AD%86%E8%A8%98/ue4/Ureal-Engine-%E5%B0%8F%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/","excerpt":"","text":"Ureal Engine 项目缓存 有unreal engine在项目构建过程中会产生大量的cache文件，这些文件对于项目工程来说很重要，适当的安排cache文件夹的位置可以避免项目在迁移时的麻烦； cache默认存储在C盘，这样长时间后将会给C盘带来很大的负担，所以可以不定期清理cache文件夹”C:\\Users\\Administrator\\AppData\\Local\\UnrealEngine\\Common\\DerivedDataCache”;cache被清理后会导致正在进行的项目已构建的材质灯光等需要重新构建和烘焙； 更改项目缓存位置为当前项目文件夹 找到对应引擎版本路径”D:\\Program Files\\Epic Games\\UE_4.24\\Engine\\Config”下的”BaseEngine.ini”文件； 使用记事本打开，在编辑栏搜索”[InstalledDerivedDataBackendGraph]”找到这一块中的” 1Local=(Type=FileSystem, ReadOnly=false, Clean=false,Flush=false, PurgeTransient=true, DeleteUnused=true,UnusedFileAge=34, FoldersToClean=-1,Path=&quot;%ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache&quot;,EditorOverrideSetting=LocalDerivedDataCache) 然后将Path=&quot;&quot;引号内容改成&quot;%GAMEDIR%DerivedDataCache&quot;； 1Local=(Type=FileSystem, ReadOnly=false, Clean=false,Flush=false, PurgeTransient=true, DeleteUnused=true,UnusedFileAge=34, FoldersToClean=-1,Path=&quot;%GAMEDIR%DerivedDataCache&quot;,EditorOverrideSetting=LocalDerivedDataCache) 关掉引擎重新打开即可；此时再次构建项目时，会在项目文件夹根目录多一个名为”DerivedDataCache”的文件夹。 默认变量Path=”%ENGINEVERSIONAGNOSTICUSERDIR%DerivedDataCache”；新变量Path=”%GAMEDIR%DerivedDataCache”。 Unreal Engine 项目迁移 临时拷贝：需要将项目临时带到别的电脑上作业时，可以将工程文件夹中除了Intermediate和Saved文件夹外整体打包进行压缩后拷贝到移动硬盘。 文件迁移：首先在UE4资源管理其中选中要迁移的目标，右键选择迁移；然后选择迁移目标工程的Content文件夹即可。 UE4程序闪退常见的几大原因 系统版本老旧 显卡驱动老旧 缺失游戏运行库 硬件不兼容(老硬件) 检查工程代码、素材 关闭全屏 Unreal Engine 工程文件结构工程文件夹结构: Config 包含了项目设置，键盘输入子类的配置文件 Content 存放工程文件的内容，包括模型、材质、代码、蓝图等 Intermediate 包含了在编译引擎或游戏时生成的临时文件 Saved 包含自动保存的内容、配置文件以及日志文件 xxx.uproject 项目启动程序，用来打开工程项目 DerivedDataCache 如果引擎的缓存变量修改成”%GAMEDIR%DerivedDataCache”那么就会在项目文件夹下生成该文件夹","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"ue4","slug":"ue4","permalink":"https://luomit.github.io/tags/ue4/"},{"name":"cache","slug":"cache","permalink":"https://luomit.github.io/tags/cache/"},{"name":"迁移","slug":"迁移","permalink":"https://luomit.github.io/tags/%E8%BF%81%E7%A7%BB/"},{"name":"缓存","slug":"缓存","permalink":"https://luomit.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"Houdini湖边小屋","slug":"筆記/houdini/Houdini湖边小屋","date":"2021-05-09T17:07:32.000Z","updated":"2021-05-09T17:07:32.145Z","comments":true,"path":"2021/05/10/筆記/houdini/Houdini湖边小屋/","link":"","permalink":"https://luomit.github.io/2021/05/10/%E7%AD%86%E8%A8%98/houdini/Houdini%E6%B9%96%E8%BE%B9%E5%B0%8F%E5%B1%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Houdini四元数(花开)","slug":"筆記/houdini/Houdini四元数-花开","date":"2021-05-08T03:38:28.000Z","updated":"2021-05-12T09:41:36.628Z","comments":true,"path":"2021/05/08/筆記/houdini/Houdini四元数-花开/","link":"","permalink":"https://luomit.github.io/2021/05/08/%E7%AD%86%E8%A8%98/houdini/Houdini%E5%9B%9B%E5%85%83%E6%95%B0-%E8%8A%B1%E5%BC%80/","excerpt":"","text":"","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"四元数","slug":"四元数","permalink":"https://luomit.github.io/tags/%E5%9B%9B%E5%85%83%E6%95%B0/"}],"author":"luomit"},{"title":"网络教程网盘资源","slug":"资源/网络教程网盘资源","date":"2021-04-28T04:44:49.000Z","updated":"2021-05-12T09:36:12.439Z","comments":true,"path":"2021/04/28/资源/网络教程网盘资源/","link":"","permalink":"https://luomit.github.io/2021/04/28/%E8%B5%84%E6%BA%90/%E7%BD%91%E7%BB%9C%E6%95%99%E7%A8%8B%E7%BD%91%E7%9B%98%E8%B5%84%E6%BA%90/","excerpt":"","text":"","categories":[{"name":"links","slug":"links","permalink":"https://luomit.github.io/categories/links/"}],"tags":[{"name":"教程","slug":"教程","permalink":"https://luomit.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Houdini","slug":"Houdini","permalink":"https://luomit.github.io/tags/Houdini/"}]},{"title":"Houdini Particle Trail","slug":"筆記/houdini/Houdini-Particle-Trail","date":"2020-12-14T08:25:05.000Z","updated":"2020-12-14T08:26:30.762Z","comments":true,"path":"2020/12/14/筆記/houdini/Houdini-Particle-Trail/","link":"","permalink":"https://luomit.github.io/2020/12/14/%E7%AD%86%E8%A8%98/houdini/Houdini-Particle-Trail/","excerpt":"","text":"Houdini 粒子路徑運動","categories":[],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"trail","slug":"trail","permalink":"https://luomit.github.io/tags/trail/"},{"name":"particle","slug":"particle","permalink":"https://luomit.github.io/tags/particle/"}]},{"title":"Smoke Pump","slug":"筆記/houdini/Smoke-Pump","date":"2020-10-11T12:00:22.000Z","updated":"2020-10-11T12:00:22.687Z","comments":true,"path":"2020/10/11/筆記/houdini/Smoke-Pump/","link":"","permalink":"https://luomit.github.io/2020/10/11/%E7%AD%86%E8%A8%98/houdini/Smoke-Pump/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Arch安装","slug":"筆記/linux/Arch","date":"2020-10-11T12:00:22.000Z","updated":"2021-05-12T09:41:33.474Z","comments":true,"path":"2020/10/11/筆記/linux/Arch/","link":"","permalink":"https://luomit.github.io/2020/10/11/%E7%AD%86%E8%A8%98/linux/Arch/","excerpt":"","text":"ArchLinux 系统安装准备开启电脑EFI启动支持(根据电脑情况选择系统启动方式)ArchLinux系统U盘 联网12345ip link # 查看网卡ip link set enp0s3 up # 启用网卡dhcpcd &amp; # dhcpcs 自动分配ip &amp;后台运行wpa_passphrase Wifi passwdping baidu.com # 检查一下是否可用 设置时间1timedatectl set-ntp true # 设置时间 修改pacman镜像源1234vim /etc/pacman.conf # 查看U盘/安装盘系统的pacman源配置vim /etc/pacman.d/mirrorlist # 编辑镜像源，在文件最开始添加阿里源(超级快)&gt; Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch # 阿里源&gt; Server = https://mirrors.tuna.tsinghua.edu.cn/manjaro/stable/$repo/$arch # 清华源 磁盘分区分区 123fdisk -l # 查看当前系统的磁盘cfdisk # 使用方向键和回车选择分区功能#EFI / swap home opt 比较常用的几个分区，EFI / swap 这三个是必须的 格式化 123mkfs.fat -F32 /dev/sda1 # 格式化EFI引导分区mkswap -f /dev/sda2 # 格式化虚拟内存mkfs.ext4 /dev/sda3 # 格式化系统分区 打开虚拟内存 1swapon /dev/sda2 # 打开/启用虚拟内存 挂载 123mount /dev/sda3 /mnt # 挂在系统根目录到U盘/安装盘的/mnt上mkdir -p /mnt/boot/efi # 创建引导分区的挂载目录mount /dev/sda1 /mnt/boot/efi # 挂载引导分区 系统安装系统核心部件安装 12pacstrap /mnt base linux linux-firmware # 将系统安装到/mnt下pacstrap base-devel neovim dhcpcd NetworkManager # 可选安装(开发工具包)、文本编辑器、网络链接工具 生成系统挂载文件 12genfstab -U /mnt &gt;&gt; /mnt/etc/fstab # 将系统挂载磁盘信息写入到fstab中cat /mnt/etc/fstab # 检查是否成功生成 时区配置 123arch-chroot /mnt # 使用这个命令进入安装在/mnt的系统ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 绑定时区hwclock --systohc # 设置时间 配置语言 1234567891011exit # 退出新系统，回到U盘系统(因为新系统没有编辑器，需要退出到U盘系统来修改配置文件)vim /mnt/etc/locale.gen # 找到zh_CN.UTF-8 UTF-8取消注释;如果需要英文就注释 en_US.UTF-8 UTF-8 取消注释arch-chroot /mnt # 再次进入新系统locale-gen # 生成语言编码exit # 再次退出vim /mnt/etc/locale.conf # 配置添加字符集 LANG=en_US.UTF_8vim /mnt/etc/hostname # 计算机名archlinuxvim /mnt/etc/host # 添加以下内容# 127.0.0.1 localhost# ::1 localhost# 127.0.0.1 archlinux.localdoamin archlinux # 这里的archlinux改为你的计算机名(pc name) 引导安装12345678arch-chroot /mnt # 进入系统pacman -S grub efibootmgr intel-ucode os-prober # 安装引导包grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=Arch # 安装引导到引导盘# EFI引导安装需要电脑支持EFI引导# 安装系统前设置bioss仅支持EFI，减少出错的概率# 如果出现这一步无法安装，退出安装后设置bioss再进来挂载系统再次尝试mkdir /boot/grub # 创建一个引导配置文件存放文件夹grub-mkconfig -o /boot/grub/grub.cfg # 生成引导配置 安装系统必要软件网络连接组件是一定要装的 12sudo pacman -S dhcpcd wpa_supplicant sudo # 必装(网络连接组件和sudo)sudo pacman -S base-devel neovim fish # base-devel必装，选装文本编辑器等 配置用户和密码添加用户 12useradd -m main # 创建用户passwd main # 设置用户密码/顺便设置root的密码 用户权限配置 1nvim /etc/sudoer # 在root ALL=(ALL) ALL 下添加 DWM桌面环境配置安装xorg显示服务器 1sudo pacman -S xorg-server xorg-apps xorg-xinit 安装显示管理器1sudo pacman -S lightdm lightdm-gtk-greeter lightdm-gtk-greeter-settings 安装终端浏览器1234sudo pacman -S w3m # 终端浏览器w3m suckless.org # 使用w3m浏览dwm官网下载dwm# tab 加 方向键移动光标到Downd按钮回车进入，分别下载dwm、dmenu、st这三个包# 找到后按回车就可以下载了，下载完成后按q退出w3m 安装dwm12345mkdir -p ~/.local/applicaions/dwm # 创建一个放置程序源码的地方mv dmenu-5.0.tar.gz dwm-6.2.tar.gz st-0.8.tar.gz st-0.8.4.tar.gz ~/.local/applicaions/dwmtar zxvf dmenu-5.0.tar.gz # 依次解压make # 依次编译sudo make install # 依次编译安装 这里注意，如果前面安装系统时没有安装base-devel包会出现编译失败的情况，可以安装这个包后再编译即可 1sudo pacman -S base-devel dwm补丁分辨率设置12345xrandrcvt 1920 1080 58xrandr --newmode &quot;1920x1080_58.00&quot; 166.00 1920 2040 2240 2560 1080 1083 1088 1119 -hsync +xsyncxrandr --addmode Virtual-1 &quot;1920x1080_58.00&quot;xrandr --output Virtua-1 --mode &quot;1920x1080_58.00&quot; 将这些设置写在~.xinitrc中 1234567# Displayxrandr --newmode &quot;1920x1080_58.00&quot; 166.00 1920 2040 2240 2560 1080 1083 1088 1119 -hsync +xsyncxrandr --addmode Virtual-1 &quot;1920x1080_58.00&quot;xrandr --output Virtua-1 --mode &quot;1920x1080_58.00&quot;# Start DWMexec dwm 字体设置安装字体 123sudo pacman -S noto-fonts-cjksudo pacman -S Source Code Prosudo pacman -S wqy-zenhei 字体修改都在源码中修改，修改完成后重新构建安装，完成修改 fcitx5输入法安装1sudo pacman -S fcitx5-im fcitx5-rime fcitx5-chewing fcitx5-chinese-addons fcitx5-material-color fcitx5-configtool 添加环境变量到 ~.xinitrc 1234# Fcitx5export GTK_IM_MODULE=fcitx5export QT_IM_MODULE=fcitx5export XMODIFIERS=@im=fcitx5 添加pinyin输入法 1fcitx5-configtool 为dwm添加托盘显示补丁systray在官网patches下找到systray下载最新的补丁程序将补丁程序放在dwm源码根目录下 12#patch &lt; 补丁名patch &lt; dwm-systray-6.2.diff rime输入法安装基于fcitx5 1fcitx5-rime 基于ibus 1ibus-rime 添加ArchlinuxCN源1234567sudo nvim /etc/pacman.conf # 添加源到配置文件# [archlinuxcn]# SigLevel = Optional TrustAll# Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$archsudo pacman -Sy # 更新源sudo pacman -S archlinuxcn-keyring # 导入GPG key 参考参考参考-Wjinlei参考-matteoZgh参考-nerdfontsfontawesome","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"Arch","slug":"Arch","permalink":"https://luomit.github.io/tags/Arch/"},{"name":"i3","slug":"i3","permalink":"https://luomit.github.io/tags/i3/"},{"name":"安装","slug":"安装","permalink":"https://luomit.github.io/tags/%E5%AE%89%E8%A3%85/"}]},{"title":"Ubuntu","slug":"筆記/linux/Ubuntu壁纸自动更换","date":"2020-10-11T12:00:22.000Z","updated":"2021-05-12T09:41:31.997Z","comments":true,"path":"2020/10/11/筆記/linux/Ubuntu壁纸自动更换/","link":"","permalink":"https://luomit.github.io/2020/10/11/%E7%AD%86%E8%A8%98/linux/Ubuntu%E5%A3%81%E7%BA%B8%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%8D%A2/","excerpt":"","text":"Ubuntu下批量壁纸自动更新的方法要在ubuntu上实现壁纸的动态更换，首先要记住两个路径下的文件/usr/share/backgrounds 这里是系统存放壁纸和壁纸动态更换脚本的地方,脚本在contest下，以.xml结尾的就是控制播放的脚本了; /usr/share/gnome-background-properties 这里的.xml和/usr/share/backgrounds/contest/下的mxl不同;这里的.xml文件是实现壁纸在系统设置中呈现，并加载动态更换脚本的; /usr/share/backgrounds/contest/groovy.xml文件原始内容如下(仅用做参考和备份)，不对这个文件做修改 下载壁纸直接贴大佬分享的帖子🐶 Python批量下载壁纸待续…. 生成控制更换xml文件脚本12345678910111213141516171819202122232425262728293031323334353637383940414243path=/mnt/User/Users/Administrator/Pictures/wallpaper-01files=`ls -U ./ | grep &#x27;[np]g$&#x27;`last_file=&#x27;empty&#x27;echo &#x27;&lt;background&gt;&#x27;echo &#x27; &lt;starttime&gt;&#x27;echo &#x27; &lt;year&gt;2020&lt;/year&gt;&#x27;echo &#x27; &lt;month&gt;11&lt;/month&gt;&#x27;echo &#x27; &lt;day&gt;4&lt;/day&gt;&#x27;echo &#x27; &lt;hour&gt;00&lt;/hour&gt;&#x27;echo &#x27; &lt;minute&gt;00&lt;/minute&gt;&#x27;echo &#x27; &lt;second&gt;00&lt;/second&gt;&#x27;echo &#x27; &lt;/starttime&gt;&#x27;echo &#x27; &lt;!-- This animation will start at midnight. --&gt;&#x27;for current_file in $filesdo if [ $last_file == &#x27;empty&#x27; ] then last_file=$current_file echo &#x27; &lt;static&gt;&#x27; echo &#x27; &lt;duration&gt;600.0&lt;/duration&gt;&#x27; echo &quot; &lt;file&gt;$path/$last_file&lt;/file&gt;&quot; echo &#x27; &lt;/static&gt;&#x27; else echo &#x27; &lt;transition&gt;&#x27; echo &#x27; &lt;duration&gt;5.0&lt;/duration&gt;&#x27; echo &quot; &lt;from&gt;$path/$last_file&lt;/from&gt;&quot; echo &quot; &lt;to&gt;$path/$current_file&lt;/to&gt;&quot; echo &#x27; &lt;/transition&gt;&#x27; echo &#x27; &lt;static&gt;&#x27; echo &#x27; &lt;duration&gt;600.0&lt;/duration&gt;&#x27; echo &quot; &lt;file&gt;$path/$current_file&lt;/file&gt;&quot; echo &#x27; &lt;/static&gt;&#x27; last_file=$current_file fidoneecho &#x27;&lt;/background&gt;&#x27;# 使用方法说明# 新建一个文件.xml在图片目录下# 执行这个脚本 ./backgrounds.sh&gt;xxx.xml 完整图片目录的填写 生成系统壁纸显示列表xml文件脚本12345678910111213141516171819202122232425262728293031323334353637path = `pwd` # 设置操作文件的目录地址，这里将图片放在了/usr/share/backgrounds下的Black文件夹里files=`ls -U ./ | grep &#x27;[np]g$&#x27;` # 匹配以pg和ng结尾的文件last_file=&#x27;empty&#x27;echo &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#x27;echo &#x27;&lt;!DOCTYPE wallpapers SYSTEM &quot;gnome-wp-list.dtd&quot;&gt;&#x27;echo &#x27;&lt;wallpapers&gt;&#x27;echo &#x27; &lt;wallpaper deleted=&quot;false&quot;&gt;&#x27;echo &#x27; &lt;name&gt;Ubuntu 20.10 Community Wallpapers&lt;/name&gt;&#x27;echo &#x27; &lt;filename&gt;&#x27;`pwd`&#x27;/xxx.xml&lt;/filename&gt;&#x27; # 这个文件指向控制文件xmlecho &#x27; &lt;options&gt;zoom&lt;/options&gt;&#x27;echo &#x27; &lt;/wallpaper&gt;&#x27;for current_file in $filesdo if [[ $last_file == &#x27;empty&#x27;]] then echo &#x27;&#x27; else last_file=$current_file file_name=$&#123;last_file##*/&#125; echo &#x27; &lt;wallpaper&gt;&#x27; echo &quot; &lt;name&gt;$&#123;last_file%.*&#125;&lt;/name&gt;&quot; echo &#x27; &lt;name xml:lang=&quot;zh_CN&quot;&gt;Ubuntu&lt;/name&gt;&#x27; echo &quot; &lt;filename&gt;`pwd`/$last_file&lt;/filename&gt;&quot; echo &#x27; &lt;options&gt;zoom&lt;/options&gt;&#x27; echo &#x27; &lt;pcolor&gt;#000000&lt;/pcolor&gt;&#x27; echo &#x27; &lt;scolor&gt;#000000&lt;/scolor&gt;&#x27; echo &#x27; &lt;shade_type&gt;solid&lt;/shade_type&gt;&#x27; echo &#x27; &lt;/wallpaper&gt;&#x27; last_file=$current_file fidoneecho &#x27;&lt;/wallpapers&gt;&#x27;# 使用方法 `sudo ./test.sh&gt;test.xml` 格式: sudo 脚本路径 &gt; 生成xml路径# sudo ./black-wallpapers.sh&gt;/usr/share/gnome-background-properties/black-wallpapers.xml [参考]","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://luomit.github.io/tags/linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://luomit.github.io/tags/Ubuntu/"},{"name":"壁纸","slug":"壁纸","permalink":"https://luomit.github.io/tags/%E5%A3%81%E7%BA%B8/"}]},{"title":"Manjaro安装","slug":"筆記/linux/i3wm","date":"2020-10-11T12:00:22.000Z","updated":"2021-05-12T09:41:32.994Z","comments":true,"path":"2020/10/11/筆記/linux/i3wm/","link":"","permalink":"https://luomit.github.io/2020/10/11/%E7%AD%86%E8%A8%98/linux/i3wm/","excerpt":"","text":"系统安装配置1.更新国内软件源 1sudo pacman-mirrors -m rank -c China 2.配置archlinuxcn 添加以下内容到 /etc/pacman.conf文件最后 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 3.更新系统并安装密钥 123sudo pacman -Syyu &amp;&amp; sudo pacman -S archlinuxcn-keyring#sudo pacman -Sy#sudo pacman -Syyu Fcitx5安装与配置(中文输入法)安装，以下代码二选一(不折腾推荐第一种)1234sudo pacman -S fcitx5 fcitx5-chewing fcitx5-chinese-addons fcitx5-configtool fcitx5-gtk fcitx5-material-color fcitx5-qt fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki# 省事版sudo pacman -S fcitx5-git fcitx5-chewing fcitx5-chinese-addons-git fcitx5-gtk-git fcitx5-material-color fcitx5-qt4-git fcitx5-pinyin-moegirl fcitx5-pinyin-zhwiki fcitx5-configtool-git fcitx5-lua-git# git 折腾版 上面两端中带-git的最好别混用，混用会使一些不能正常的使用(…..) 配置fcitx5在 ~/.xprofile 文件内添加以下内容(如果该文件不存在，则使用 touch ~/.xprofile 创建) 1234export WINEARCE=win32 # 来自网络大佬，可以解决终端无法输入文字的问题export GTK_IM_MODULE=fcitx5export QT_IM_MODULE=fcitx5export XMODIFIERS=&quot;@im=fcitx5&quot; 字体安装123456sudo pacman -S noto-fonts-cjk adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts adobe-source-code-pro-fontssudo pacman -S ttf-font-icons ttf-font-awesomesudo pacman -S powerline powerline-fonts powerline-vim# 第一行系统中文支持字体# 第二行i3bar图标支持字体# 第三行zsh图标支持字体 配置系统字体1sudo nano ~/.config/fontconfig/fonts.conf 软件安装1234567891011121314151617sudo pacman -Sy google-chrome # 谷歌浏览器sudo pacman -S typora # 笔记神器sudo pacman -S keepassxc # 密码管理软件sudo pacman -S netease-cloud-music # 网易云音乐sudo pacman -S screenkey # 一个可以将当前执行按键打印到屏幕上人的软件(平时用不到)sudo pacman -S kdenlive # 开源的视频剪辑软件sudo pacman -S gimp # 一个可以制作矢量图的绘图软件sudo pacman -S libreoffice # offoce 有些人的刚需sudo pacman -S vlc # 强大的视频播放器sudo pacman -S virtualbox # 虚拟机使用爱好者sudo pacman -S deepin.com.qq.im # deepin的qq,前提是前面配置了archlinuxcnsudo pacman -S electronic-wechat # linux微信sudo pacman -S qbittorrent # 下载工具软件sudo pacman -S transmission-qt # 下载工具软件transmission-gtksudo pacman -S ranger # 文件管理器sudo pacman -S steam # 游戏sudo pacman -S fzf # 终端搜索文件 硬盘挂载1sudo blkid # 获取磁盘uuid磁盘类型等信息 将得到的信息按照以下格式,添加/修改 /etc/fstab文件进行磁盘的挂载 12345# &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;UUID=b351246c-0652-430e-98ab-3d65d53981fc / ext4 defaults,noatime 0 1UUID=0b616041-f450-44ea-af6e-95d027f8da7b /opt ext4 defaults,noatime 0 2UUID=8ceec14d-3ee1-48cb-9679-58d843793b5a /home ext4 defaults,noatime 0 2# 以上这些挂载到 / 、 /opt 、/home 的盘千万别动 使用磁盘管理用具获取要挂载磁盘的uuid或者使用以下代码获取指定盘的uuid 123fdisk -l # 获取磁盘列表(sudo)mount /dev/sda1 /mnt/pc01 # 挂载硬盘sda1到/mnt/pc01ls -l /dev/disk/by-uuid # ls -l 磁盘路径/byuuid 获取磁盘的uuid(ls -l 磁盘路径,可获得更多的使用方法) 把获得的磁盘参数写到 /etc/fstab 的最后，格式如下 123UUID=0A9AD66165F33762 /mnt/project ntfs defaults 0 0UUID=462E0E842E0E6D6D /mnt/assets ntfs defaults 0 0UUID=8909b9af-a192-4539-a5e9-12d3d4d1857e /mnt/work ntfs defaults 0 0 I3安装与配置安装1sudo pacman -S i3 # 直接回车(我全都要) 使用命令终端安装,配置文件位置一般在 $HOME/.config/i3/config，如果使用包管理器安装可能会在$HOME/.i3/config ;实际位置会因为使用的发行版不同而略有出入。 插件与配置1234567sudo pacman -S i3status polybar ranger tmux variety rofi compton # picom comptonsudo pacman -S highlight atool w3m poppler mediainfo # ranger实用插件exec_always --no-startup-id xranr --output HDMI-0 --mode 1920x1080 #每次重载i3设置屏幕HDMI-0的分辨率exec_always --no-startup-id $HOME/.config/polybar/launch.sh #启动polybarexec_always --no-startup-id fcitx5 #启动输入法exec --no-startup-id variety #启动variety壁纸插件exec --no-startup-id rofi #启动rofi程序启动器 variety/reh壁纸软件安装任意一个，前者设置比较简单，后者可以代码自定义，也许拓展性更强吧 1exec_always --no-startup-id feh --randomize --bg-fill ~/图片/* rofi程序启动器123sudo pacman -S rofi rofi-script # 安装mkdir -p ~/.config/rofi # 创建配置文件rofi -dump-config &gt; ~/.config/rofi/config # 生成配置文件 然后在~.config/i3/config里添加下面的启动配置代码 1bindsym $mod+d exec rofi -show run -theme Arc-Dark #所有支持的主题在 路径下 ranger 文件管理软件功能丰富，用法快捷键较多，需要熟练 1ranger --copy-config=all #生成配置文件 它的常用插件：highlight 代码高亮、atool存档预览、w3m html文件预览、poppler pdf文件预览、mediainfo 多媒体文件预览 alacritty 终端12bindsym $mod+Return exec alacritty # 注释掉i3配置文件里原本的终端启动添加这一句new_window 1pixel # 设置新建窗口的边框为1像素，无边框设置 tmuxpicom 程序透明1234sudo pacman -S picom # 安装cp /etc/xdg/picom.conf ~/.config/ # 复制默认的配置文件sudo chown ~/.config/picom.conf # 赋予修改权限exec_always --no-startup-id picom # 添加到~/.config/i3/config 修改~/.config/picom.conf配置文件picom wiki pacmixer 音频音量控制1sudo pacman -S pacmixer 安装lxappearance美化系统主题图标12sudo pacman -S lxappearance # 安装lxappearance # 执行该指令进行配置 polybar dock自定义软件时混的强大，但是配置相对麻烦 123sudo pacman -S polybar # 安装mkdir ~/.config/polybar # 创建配置文件夹cp /usr/share/doc/polybar/config ~/.config/polybar/ # 复制官方配置为自己的配置 创建一个启动配置文件launch.sh并写下以下内容，sudo chmod +x ~/.config/polybar/launch.sh 赋予执行权限 12345678910111213141516171819#!/usr/bin/env bash# 关闭若有打开的polybarkillall -q polybar# 等待已经打开的polybar关闭while pgrep -u $UID -x polybar &gt;/dev/null; do sleep 1; done# 运行bar1，bar2 可以一次定制多个barif [ &quot;$1&quot; == &quot;light&quot; ]then polybar -c $HOME/.config/polybar/light-config nord-top &amp; polybar -c $HOME/.config/polybar/light-config nord-down &amp;else polybar -c $HOME/.config/polybar/dark-config nord-top &amp; polybar -c $HOME/.config/polybar/dark-config nord-down &amp;fiecho &quot;Bars launched...&quot; 添加i3运行执行配置 ，将以下内容添加到~/.config/i3/config 1exec_always --no-startup-id $HOME/.config/polybar/launch.sh fish 终端美化12sudo pacman -S fish # 安装fishfish_config # 配置fish I3特定功能配置方法总结终端pacman高亮/etc/pacman.conf 中将color解除注释 屏幕整体显示大小缩放编辑~/.Xresources文件添加以下内容 1Xft.dpi:150 # 数字越大桌面字体整体缩放越大 xorg修改linux系统键位123sudo pacman -S xorg # 键位修改程序xmodmap -pke &gt; ~/.xmodmap # 将xmodmap当前的键位信息打印输出到.xmodmap文件内xev # 终端执行该指令，会出现一个新的窗口，当按下键盘时，终端会显示到按键对应的keycode编号 如下所示，想要将keycode编号为110的键与keycode编号为111的键调换位置 1234keycode 110 = F11 F11 F11keycode 111 = F08 F08 F08keycode 110 = F08 F08 F08keycode 111 = F11 F11 F11 参数调换完成后在.xmodmap文件的最前面添加以下内容(清除要修改的键位) 12clear F11clear F08 然后再在.xmodmap文件的最后面添加以下内容(添加要修改的键位) 12add F11 = F08add F08 = F11 保存退出，ok完成键位的修改 1xmodmap ~/.xmodmap # 刷新键位修改 i3延时执行指令12# exec_always #这个修饰符开始的命令会在i3刷新时跟随刷新exec_always sleep 1; fcitx5 # sleep 1; 延迟1秒启动 fcitx5 i3设置程序快捷键1bindsym $mod+d exec rofi -show run -theme Arc-Dark # bindsym 快捷键组合 exec 程序名(或者完整路径) 后面还可添加其他一些对这个程序运行的一个修饰指令 i3杀死程序/进程12exec_always kill firefoxexec_always killall firefox i3-gaps设置窗口边缘间隙12sudo pacman -S i3-gaps # 如果终端安装i3时全部安装了i3就不用单独安装;如果没有也可以单独安装gaps inner 10 # 添加到~/.config/i3/config 实现窗口间隙为10个像素 Ranger 基本的使用安装与配置123sudo pacman -S ranger # 安装rangersudo pacman -S highlight atool w3m poppler mediainfo # 常用插件安装ranger --copy-config=all # 生成配置文件~/.config/ranger/ 配置文件在~/.config/ranger/ 下rc.conf 快捷键配置commands.py 配置可以通过 ：来执行的程序rifile.conf 指定不同文件类型的打开程序 常用快捷键 按键 说明 按键 说明 r 选择打开文件方式打开文件 [ ] 移动父级光标 /? 搜索文件 Q 退出目录 Shift+S 退出到当前操作文件位置 yp 复制当前选中文件路径 H 后退 yy 复制 L 前进 dd 剪切 gg 跳到顶端 pp 粘贴 G 跳到底端 delete 删除 gh go home cw 重命名 gn 新建标签 A 在当前名字的基础上重命名 f 查找 I 与A类似,光标在名字最前面 / 搜索 Ctrl+f 向下翻页 g 快速进入目录 Ctrl+b 向上翻页 m 新建书签 on/ob 根据文件名排序 ` 打开书签 oc 根据文件权限修改时间排序 um 删除书签 os 根据大小排序 gn/C-n 新建标签 ot 根据类型排序 TAB/S-TAB 切换标签 oa 访问/使用时间排序 A-Rignt,A-Left 切换标签 om 根据文件修改时间排序 gc/C-w 关闭标签 Ctrl + /Ctrl - 缩放显示大小 参考帮助 RenderWiKi查看更多使用技巧 TheCWbilibili讲解视频 Manjaro 杂七杂八火狐配置报错无法打开,使用以下命令重新配置(这样做你之前对浏览器的设置就没了)1firefox -profilemanager 查看显示器123xrandr#DVI-D-1#HDMI-1 配置显示器显示顺序(多显示器)1exec --no-startup-id xrandr --output HDMI-0 --left-of DVI-D-0 --auto 可以在~/.xinitrc中配置，也可以在～/.config/i3/config 中配置推荐使用后者，这样做就算配置出错也不会导致图形界面无法进入 显卡安装(参考)1234567891011inxi -G # 查看显卡硬件mhwd # 查看安装驱动列表sudo pacman -S virtualgl lib32-virtualgl lib32-primus primus# 安装依赖sudo systemctl enable bumblebeed # 开机自启动bumblebeed服务sudo gpasswd -a $USER bumblebee # 将用户添加到bumblebee组screenfetch # 打印系统信息nvidia-smi # 查看显卡驱动信息sudo pacman -S mesa-demos # 安装测试工具glxgears -info # 集成显卡性能optirun glxgears -info # 独立显卡性能#最终翻车，诶怪自己功力不够深厚 显卡的安装水很深，功力不足不建议尝试，使用官方的就很安逸 Manjaro Gcc 版本修改（失败）1234567sudo pacman -Ss gcc # 查看可安装的版本sudo pacman -S gcc8 gcc8-fortran gcc8-libs # 安装gcc8cd /usr/bin/ls -al gcc* # 查看gcc8有没有安装成功sudo mv gcc gcc_back # 备份gccsudo cp gcc-8 gcc # 复制gcc-8为默认gccgcc -v # 成功 小白操作 Manjaro I3 安装Houdini库安装123sudo pacman -S libXss lib32-libxss # Manjaro i3 我查看的时候已经安装好了一3 我查看的时候已经安装好了一个sudo pacman -S glu lib32-glu libgssglue # 有些是Manjaro已经安装了的就不用再安装了sudo pacman -S libnsl lib32-libnsl # GCC版本我已经从最新降到gcc8了 Houdini 安装123456sudo su # 先获得管理员权限./houdini.install # 安装 一路y&gt;&gt;&gt;y&gt;&gt;&gt;y&gt;&gt;y&gt;&gt;&gt;yes&gt;&gt;&gt;yes直至完成安装，期间可能会遇到的问题# 问题一：安装成功，但是提示包损坏，没有完全安装;# 可能的原因：缺少依赖包，或者依赖包的版本过高，可以将上面提到的库的旧版本装一下# 问题二：安装失败或者无法安装;# 可能的原因：gcc版本太新，降低版本即可; 你懂的准备sesinetd服务程序(linux版和谐的) 1234sudo /etc/init.d/sesinetd stop # 停止服务sudo mv /usr/lib/sesi/sesinetd /usr/lib/sesi/sesinetd_old # 备份sudo cp sesinetd /usr/lib/sesi/ # 复制替换sudo /etc/init.d/sesinetd start # 启动服务 运行 IP配置(以下是垃圾)XJB折腾浏览器输入IP进行搜索获取本计算机ip 171.107.24.49 ip 1234567891011nano /etc/rc.conf # 编辑配置文件interface=eth0 # 网卡名称address=192.168.21.170 # IP地址netmask=255.255.255.0 # 子网掩码broadcast=192.168.21.255 # 这个是广播地址，根据IP地址和子网掩码计算得到gateway=192.168.21.2 # 网关nano /etc/resolv.conf #编辑配置文件nameserver 8.8.8.8nameserver 8.8.4.4ctrl+o #保存ctrl+x #退出 开始 123456ip addr # 查看网卡如果安装了net-tools可以使用ifconfig# enp5s0# enp0s31f6sudo systemctl disable --now systemd-network.servicecode /etc/systemd/network/enp5s0.networksudo systemctl enable --now systemd-network.service 安逸的方法直接安装dhcpcs 123sudo pacman -S dhcpcdsudo ip link set &quot;网卡名&quot; upsudo dhcpcd &amp; 開機執行编辑 ~/.xinitrc 文件，在最後添加 123#!/usr/binexec ip link set &quot;网卡名&quot; upexec dhcpcd 或者寫成一個腳本，在~/.xinitrc中启动 I3美化/优化","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"i3","slug":"i3","permalink":"https://luomit.github.io/tags/i3/"},{"name":"安装","slug":"安装","permalink":"https://luomit.github.io/tags/%E5%AE%89%E8%A3%85/"},{"name":"Manjaro","slug":"Manjaro","permalink":"https://luomit.github.io/tags/Manjaro/"}]},{"title":"ShellScript III","slug":"筆記/shell/ShellScript-III","date":"2020-10-07T12:00:22.000Z","updated":"2021-05-12T09:41:23.310Z","comments":true,"path":"2020/10/07/筆記/shell/ShellScript-III/","link":"","permalink":"https://luomit.github.io/2020/10/07/%E7%AD%86%E8%A8%98/shell/ShellScript-III/","excerpt":"","text":"函数shell函数的本质是一段可以反复使用的脚本代码，这段代码被提前编写好了，放在指定的位置，当用户需要使用时直接调用即可 函数定义函数定义的格式如下: 12345678910111213# 带参数函数定义function funname[()]&#123; commands [retun value]&#125;# 不带参数函数定义funname[()]&#123; commands [retun value]&#125; 说明： function 是shell的关键字，专门用来定义函数； name 是函数名； commands 是函数执行代码，可以是一行或者多行； return value 表示函数的返回值，其中return是shell的关键字，专门用在函数中返回一个值；这一部分可写可不写； 由{}包含的部分称为函数体，调用一个函数实际上就是执行这个函数的函数体中的代码； 1234567891011121314#!/bin/bashfirst()&#123; echo &quot;my first function!&quot;&#125;first# 直接调用 返回 &quot;my first function!&quot;#!/bin/bashfirstReturn()&#123; read -p &quot;请输入第一个数值: &quot; num1 read -p &quot;请输入第二个数值: &quot; num2 return $(($num1*$num2))&#125;firsRetunecho &quot;两数的乘积为 $? &quot; 函数的优势 方便多次调用，减少代码量使脚本更加简洁轻量； 方便修改，当需要对脚本进行维护时，调用函数的部分只需要修改函数脚本即可； 将函数写进文本，在写其他脚本时可直接调用已经写过的脚本； 调用函数不带参数的函数在调用不带参数的函数时，直接输入函数名即可调用函数；执行函数时，函数名前的关键字function和函数名后面的()均不需要带；函数的定义必须要在执行的程序前定义和加载； 带参数的函数12functionName arg1 agr2# 函数名 参数1 参数2 shell 中的位置参数(1/2/3/….？/$@)均可以作为函数的参数进行传递； $0比较特殊，仍然是代表父脚本的名称； 此时父脚本的参数会临时被函数的参数所掩盖或隐藏 函数的参数变量是在函数内进行定义的 执行函数总结 shell各种程序的执行顺序为: 系统别名&gt;&gt;函数&gt;&gt;系统命名&gt;&gt;可执行文件等； 函数执行时，会和调用它的脚本共享变量，也可以为函数设定局部变量及特殊位置参数； 在shell函数里面，return和exit功能类似，区别时return是退出函数，exit是退出脚本； return语句会返回一个值给调用函数的程序，exit则会返回一个值给执行当前脚本的shell； 如果将函数单独存放为一个文件，在加载时需要使用source或.进行加载； 在函数内部一般使用local定义局部变量，仅在函数体内有效 调用函数for循环while循环until循环","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://luomit.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://luomit.github.io/tags/shell/"}]},{"title":"ShellScript II","slug":"筆記/shell/ShellScript-II","date":"2020-10-06T12:00:22.000Z","updated":"2021-05-12T09:41:23.852Z","comments":true,"path":"2020/10/06/筆記/shell/ShellScript-II/","link":"","permalink":"https://luomit.github.io/2020/10/06/%E7%AD%86%E8%A8%98/shell/ShellScript-II/","excerpt":"","text":"通配符shell的通配符(元字符)表示的不是本意。 常见的通配符 字符 含义 实例 * 匹配0或多个任意字符 a*b ,a与b之间可以是任意长度的字符，包括0个；比如ab、acb、acdvb等 ？ 匹配任意一个字符 a?b ,a和b之间必须要有一个字符，该字符可以时任意字符；比如acb、avb、aab等 [list] 匹配list中任意单个字符 a[sdc]b ,a与b之间必须要有一个字符；例如asb、adb、acb [!list] 匹配除了list这几个字符以外的任意单个字符 a[!a-z]b ,a和b之间必须存在一个字符,且该字符不能是小写字母；例如aAb、aBb、aCb等 [c1-c2] 匹配c1到c2之间的任意单个字符 a[0-2]b ,a与b之间必须但也只能存在一个字符，该字符只能是数字；例如a0b、a1b、a2b {string1,string2,….} 匹配string1、string2，….中任意一个字符串 q{abc,cdv,sfd}v ,a与v之间必须也只能存在{}中的其中一个字符；例如qabcv、qcdvv、qsfdv 脚本规范 解释器环境配置 在编写解释型语言时，大多数时候要在脚本开头指定执行脚本的解释器路径；这样做是为了脚本在执行时可以找到执行脚本的解释器；如果没有写，脚本会使用系统默认的解释器来运行或者报错； 123#！/bin/bashecho &quot;hello world&quot;# 第一句就是告诉脚本要使用/bin/下的bash来运行当前脚本 在linux中为了避免用户在系统安装或脚本环境配置过程中没有将解释器安装在默认的路径上；可以使用env来搜索指定目录下相应的解释器；且这种写法的适应性相对较强，所以使用得比较频繁； 12345#！/bin/env bashecho &quot;hello world&quot;# 推荐使用这种适用性较强的写法cat /etc/shells# 查看系统支持的解释器 脚本注释 对于写代码的程序员来说，在读没有注释的脚本就是一种折磨；工整完善的注释可以让其他人了解代码作者书写代码时的思路，可以更好更快的理解代码的意图和脚本的实现过程；当你长时间没有接触后再次阅读也可以快速的进行继续开发，提升工作效率；脚本的注释一般包括：shebang(第一行的解释器指定)，脚本的参数，脚本的用途，脚本的注意事项，脚本的写作作者、时间、版权等，各个函数的说明注释，一些较为复杂的单行命令注释 参数规范 这一点很重要，因为在代码的运行过程中难免会出现报错等杂七杂八的问题，规范的书写方式可以更好的检查代码，方便纠错 1234if [[ $# != 2 ]];then echo &quot;Parameter incorrect&quot; exit 1fi 变量 变量的使用时很常见的，一般会将变量的定义放在脚本的开头(脚本正文开头与shebang之间)，方便管理和修改； 12path=&#x27;home/main/.config&#x27;$path 缩进 正确的缩进可以使代码的可读性更强，让其他人更容易读懂作者的代码；而且缩进也可以使代码的观感更好，如果将所有的代码都写成一条一条的那也太无趣了些； 常见的缩进方法主要有“soft tab”和“hard tab”两种： soft tab就是使用n个空格进行缩进(n通常为2、4或8) hard tab指定是真是的‘\\t’字符12 命名标准 命名的规范包括一下几点： 文件名规范，文件名通常要使用小写，不要使用中文，避免乱码等不必要的错误风险；以.sh结尾，方便识别 变量名要有含义，注意拼写不要出错 统一命名的风格，写shell通常使用小写加下划线 编码统一 写脚本的时候尽量使用UTF-8编码，这样脚本内的注释就可以支持中了；不过在写注释以及打log的时候尽量使用英文，毕竟有些机器上可能没有安装对中文的支持，这会导致打出的log可能是乱码； 日志回显 日志可以方便程序员对代码的纠错，特别是在大型项目或多人协同完成的项目中尤其重要；日志还可以回显一些提示，方便用户对脚本运行状态的了解和掌控；还可以为日志回显添加一些特效、色彩、表情等提高用户体验； 移除密码 不要在代码中暴露密码等重要信息，特别是在使用github等公共和开放的代码托管网站的时候； 太长分行在代码的编写时，过长的代码会影响代码的执行效率和代码的阅读体验；如果遇到代码过长且无法避免时，可以使用\\号来对代码进行分行； 123456./configure-prefix=/usr-sbin-path=/usr/sbin/nginx-conf-path=/etc/nginx/nginx.conf# 可以写成./configure-prefix=/usr\\-sbin-path=/usr/sbin/nginx-conf-path=/etc\\/nginx/nginx.conf 代码效率 在代码编写时不要在单行中使用过多的管道来编写脚本，太长的代码影响代码的运行效率和代码的可读性；可以将代码分成多行代码来编写，这样可使得代码更加易读； 路径严谨在很多情况下脚本需要获取当前脚本所在的路径，然后以这个路径为基准来查找需要的其他文件位置；通常会使用pwd来获取当前的脚本路径； 不过以上获取当前脚本路径的方法并不严谨，pwd获取的是当前shell的执行路径，而是不是当前脚本的路径； 正确的写法应该是 12script_dir=$(cd $(dirname $0) &amp;&amp; pwd)script_dir=$(dirname $(readlink -f $0)) 12 cd进入当前脚本的目录然后在使用pwd或者直接获取当前脚本的所在路径 代码简洁 新写法 其他 路径尽量保持绝对路径，不容易出错，如果非要使用，最好使用./来修饰； 优先使用bash的变量替代awk sed，这样更加简洁； 简单的if尽量使用&amp;&amp; ||，写成单行；比如 [[x&gt;2]] &amp;&amp; echo x 当export变量时，尽量加上子脚本的namespace，保持变量不冲突 会使用trap捕获信号，并接收到终止信号时执行一些收尾工作 使用mktemp生成临时文件或文件夹 利用/dev/null过滤不友好的输出信息 会利用命令的返回值判断命令的执行情况 使用文件时要判断文件是否存在，否则做好异常处理 不要处理ls后的数据(比如 ls-l | awk’{print $8}’) ls的结果非常的不确定，并且与平台有关 读取文件时不要使用for loop而要使用while read 调试shell脚本的语法调试，使用bash的相关参数进行调试; bash [参数] 文件名.sh -n 不执行script，仅查询语法错误； -v 在执行script之前，先将script内容显示到终端 -x 将使用的脚本内容输入到终端，该参数经常被使用 123bash -n script.shbash -x script.shbash -v script.sh 脚本的运行方式123456789101112# bash环境执行bash script.sh# 工作目录执行chmod +x script.sh./script.sh# 相对路径执行~/shell/script.sh# 绝对路径执行/home/main/shell/script.sh 变量变量通俗的可以理解为用于个固定不变的字符串，来表示或者替代一个可变化的内容；变量又可以分为自定义变量、环境变量、位置变量和预定义变量； 自定义变量自定义变量则是程序员自己定义的变量，变量的定义必须要以字母或者下划线开头并且字母区分大小写； 变量名=变量内容 123456789shell=/usr/bin/bash# 定义变量shell等于/usr/bin/bashdir=`pwd`# 定义变量dir等于pwd的执行结果echo $direcho $shell# 使用$加变量名,来调用定义的变量 引用变量(变量的调用) 查看变量: echo $变量名 取消变量: unset 变量名 作用范围: 仅在当前shell中有效 环境变量定义环境变量 export home_dir=/home/main 定义环境变量 export blog_dir=/home/main/.blog export blog_dir 将变量转换成环境变量 引用环境变量: 变量名 或 {变量名} 查看环境变量: echo $变量名 取消环境变量: unset 变量名 作用范围在当前shell和子shell中起作用 位置变量在linux执行脚本命令过程中会使用到多个参数，可以使用系统定义的位置变量来表示这些参数； 其中，$0代表命令行本身，$1代表第一个参数，$2代表第二个参数以此类推；当参数个数大于9个时，就要用{}来将位置参数括起来，例如${10}代表第十个参数，${15}代表第十五个参数； 12ls ~/.blog ~/.config ~/Download# 以这一条命令来说， $0代表ls本身， $1就代表~/.blog, $2就代表~/.config 在shell中可以识别的位置参数变量如下表：|位置参数变量|作用||:—:|:—:||$n|n为数字，$0代表命令本身，$19代表第19个参数，10及其以上的参数需要大括号包含，例如${10}||$*|这个变量代表命令行或者脚本中的所有参数,并把所有参数看作是一个整体||$@|这个变量代表命令行或者脚本中的所有参数，不过$@把每个参数区别对待||$#|这个命令代表命令行或者脚本中所有参数的个数| 预定义变量预定义变量时shell在一开始时就定义好的变量，这一点和默认的环境变量有点相似；但是预定义变量不能重新定义，用户只能根据shell的定义来使用这些变量。严格来说，位置参数变量也是预定义变量的一种，只是位置参数变量的所用比较统一，所以位置参数变量被单独划分为一类； shell中的预定义变量如下表：|预定义变量名|作用||:—:|:—:||$?|最后一次执行命令的返回状态，如果这个变量的值为0，则证明上一条命令正确执行；如果这个变量的值为非0(具体是哪个参数由命令决定)，则证明上一条命令执行错误||$$|当前进程的进程号(PID)||$!|后台运行的最后一个进程号的(PID)| 123lsecho $?# 如果ls正确执行，那么 echo $? 就会返回0(当然预定义变量只在linux系统默认的bash中有效，如果使用fish或者zsh等第三方shell可能会无效) 变量的赋值方式显式赋值变量名=变量值 12ip=198.168.1.1blog_path=/home/main/.blog read从键盘读取变量值 read 变量名 read -p “提示信息” 变量名 read -t 5 -p “提示信息” 变量名 read -n 2 变量名 read用法: read [-ers] [-a数组] [-d分隔符] [-i缓冲区文字] [-n读取字符数] [-N读取字符数] [-p读取提示符] [-t超时] [-u文件描述] [名称….] 123#!/bin/bashread -p &quot;请输入你的名字&quot; nameecho $name 如上脚本，变量$name需要用户输入，然后脚本再调用这个变量； 单双引号的区别在shell中’’和””起到的效果略有不同；在执行命令过程中，如果使用单引号包含一个变量，那将无法正确的返回这个变量的结果；如下所示: 123a=2echo &#x27;$a&#x27;echo &quot;$a&quot; 可以从结果看出，以单引号’’包围变量的值时，单引号内部是什么就输出什么，即使所包含的内容中含有变量和命令(命令需要``反引包含)也会把它们原样输出；这种情况非常适合定义显示字符串的情况，即不希望解析变量和命令等场景； 以双引号””包含的变量值时，输出前会先解析双引号内部的变量和命令，再把结果一并输出；为而不是将双引号的内容原样输出；这种情况适用于字符串中附带有变量和命令的脚本，需要将变量和命令先解析后再将结果和字符串一并输出。 在shell中单引号’’也称强引，双引号称为弱引； 反引号``当用户定义一个带有命令或变量的变量时，为了让脚本将命令和变量先执行后再将结果用于定义变量；这时需要使用``反引号告诉脚本这是一行命令或者变量; 12a=`ls ~/.config/fish`files=`ls -U ./ | grep &#x27;[np]g$&#x27;` 变量的删除、替换过滤123456789101112131415url=https://www.bilibili.comecho $&#123;$url&#125;# 获取变量的长度echo $&#123;url&#125;# 获取变量值echo $&#123;url#*.&#125;# 从前往后，最短匹配；这里返回bilibili.comecho $&#123;url##*.&#125;# 从前往后，最长匹配；这里返回 .comecho $&#123;url%.*&#125;# 从后往前，最短匹配；这里返回 https://www.bilibiliecho $&#123;url%%.*&#125;# 从后往前，最长匹配；这里返回 https://www 切片12echo $&#123;url:6:3&#125;# 意思是从变量值第6个字符开始(不包含第六个)，打印3个字符；这里返回 //w 替换1234567echo $&#123;url/bilibili.com/luomit.xyz&#125;# 内容的替换 $&#123;变量名/旧内容/新内容&#125;; 这里返回https://www.luomit.xyzecho $&#123;url/b/B&#125;# $&#123;变量名/旧内容/新内容&#125;; 这里会替换url中第一个小写b为大写的Becho $&#123;url//b/B&#125;# $&#123;变量名//旧内容/新内容&#125;; 这里会将所有的小写b替换为大写的B i++ 与 ++i两者都会对变量执行递增的一个操作；区别在于前者不影响原始变量，而后者将改变原始变量的值； 123456789101112131415i=1j=1x=0y=0let x=i++let y=++jecho $i# 2echo $j# 2echo $x# 1echo $y# 2# 由结果可以看出，x的值时i一次累加获得的值，后面的累加不在赋予到变量x上；而y的值时j的两次累加的结果； i++ 是先赋值再运算，运算结果不再影响赋值； ++i 先运算再赋值，赋值的结果等于运算结果 参考","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://luomit.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://luomit.github.io/tags/shell/"}]},{"title":"Vim 配置","slug":"筆記/linux/Vim配置","date":"2020-10-05T12:00:22.000Z","updated":"2021-05-12T09:41:30.627Z","comments":true,"path":"2020/10/05/筆記/linux/Vim配置/","link":"","permalink":"https://luomit.github.io/2020/10/05/%E7%AD%86%E8%A8%98/linux/Vim%E9%85%8D%E7%BD%AE/","excerpt":"","text":"vim基础Vim 是一个优秀的终端文本编辑器，可以不使用鼠标，完全键盘操作；对新手不太友好，一旦适应了键盘操作的习惯，可以极大的提高工作效率；且系统占用较小，打开较大的文件也不会有任何压力； Vim在启动时会根据配置文件(.vimrc)来配置Vim，因此我们可以通过这个文件来定制适合自己使用习惯的Vim； vim的默认配置在 /etc/.vimrc vim用户的配置通常位于 ~/.vimrc Vim环境变量设置参数 设置参数 功能描述 set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936;set termencoding=utf-8;set encoding=utf-8 设置编码格式，enconding选项用于缓存的额文本、寄存器、Vim脚本文件等；fileencoding选项是Vim写入文件时采用的编码类型；termencoding选项表示输出到终端时采用的编码类型 set nu;set num nu时number的缩写，所以这两个配置命令效果是一样的；取消行号可以使用set nonu set cursorline 突出显示当前行 set mouse=a;set selection=execlusive;set selectmode=mounse,key Vim默认是不启用鼠标的，可以通过此配置启用鼠标 set autoindent 设置自动缩进，即每一行的缩进同上一行相同 set tabstop=4 设置Tab键宽度为4个空格 将上面这些内容写进~/.vimrc中可以让vim启动时加载，避免每次使用都要再次配置 自用部分配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&quot; 设置环境变量set showcmd &quot; Show (partial) command in status line.set showmatch &quot; Show matching brackets.set ignorecase &quot; Do case insensitive matchingset incsearch &quot; Incremental searchset mouse=a &quot; Enable mouse usage (all modes)set number &quot; 显示行号set cursorline &quot; 高亮当前行set textwidth &quot; 设置行宽,即一行显示多少个字符set wrap &quot; 自动折行set linebreak &quot; 不会在单词中间折行set wrapmargin=2 &quot; 指定折行处与右边缘之间空出的字符&quot;set spell spelllang=en_us &quot; 英语拼写检查set autochdir &quot; 自动切换文件路径set visualbell &quot; 出错闪屏幕set autoread &quot; 文件改变提示set wildmenuset wildmode=longest:list,full &quot; tab补全，再次tab依次选择提示set encoding=utf-8 &quot; 设置编码set backupdir=~/.config/nvim/.backup// set directory=~/.config/nvim/.swp//set undodir=~/.config/nvim/.undo//&quot; 安装插件 startcall plug#begin(&#x27;~/.config/nvim/plugged&#x27;)Plug &#x27;mattn/emmet-vim&#x27; &quot;插件的github位置&quot;Plug &#x27;https://github.com/vim-scripts/fcitx.vim.git&#x27;&quot;Plug &#x27;norcalli/nvim-colorizer.lua&#x27;Plug &#x27;vim-airline/vim-airline&#x27;Plug &#x27;vim-airline/vim-airline-themes&#x27; &quot; 状态栏配置&quot;Plug &#x27;altercation/vim-colors-solarized&#x27;Plug &#x27;joshdick/onedark.vim&#x27; &quot; 主题Plug &#x27;junegunn/vim-easy-align&#x27; &quot; 自动对齐Plug &#x27;jiangmiao/auto-pairs&#x27; &quot; 自动引号&amp;括号补全Plug &#x27;luochen1990/rainbow&#x27; &quot; 括号色彩匹配Plug &#x27;preservim/nerdtree&#x27;Plug &#x27;Xuyuanp/nerdtree-git-plugin&#x27; &quot; 文件树状结果Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125; &quot; coc补全插件Plug &#x27;zchee/deoplete-jedi&#x27; &quot; pythonPlug &#x27;scrooloose/nerdcommenter&#x27; &quot; 注释插件Plug &#x27;scrooloose/syntastic&#x27; &quot; 语法检查call plug#end()&quot; 安装插件 End&quot; 主题颜色syntax onset background=darkcolorscheme onedarklet g:onedark_termcolors=256let g:airline_theme=&#x27;onedark&#x27;let g:lightline = &#123; \\ &#x27;colorscheme&#x27;: &#x27;onedark&#x27;, \\ &#125;&quot; autocmd vimenter * NERDTree &quot; 自动开启Nerdtreelet g:NERDTreeWinSize = 25 &quot; 设定 NERDTree 视窗大小let NERDTreeShowBookmarks=1 &quot; 开启Nerdtree时自动显示Bookmarks&quot;打开vim时如果没有文件自动打开NERDTree&quot; autocmd vimenter * if !argc()|NERDTree|endif&quot;当NERDTree为剩下的唯一窗口时自动关闭autocmd bufenter * if (winnr(&quot;$&quot;) == 1 &amp;&amp; exists(&quot;b:NERDTree&quot;) &amp;&amp; b:NERDTree.isTabTree()) | q | endif&quot; 设置树的显示图标let g:NERDTreeDirArrowExpandable = &#x27;+&#x27;let g:NERDTreeDirArrowCollapsible = &#x27;-&#x27;let NERDTreeIgnore = [&#x27;\\.pyc$&#x27;] &quot; 过滤所有.pyc文件不显示let g:NERDTreeShowLineNumbers=0 &quot; 是否显示行号let g:NERDTreeHidden=0 &quot; 不显示隐藏文件&quot;&quot;Making it prettierlet NERDTreeMinimalUI = 1let NERDTreeDirArrows = 1nnoremap &lt;F3&gt; :NERDTreeToggle&lt;CR&gt; &quot; 开启/关闭nerdtree快捷键&quot; 按键配置","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://luomit.github.io/tags/linux/"},{"name":"vim","slug":"vim","permalink":"https://luomit.github.io/tags/vim/"},{"name":"neovim","slug":"neovim","permalink":"https://luomit.github.io/tags/neovim/"}]},{"title":"ShellScript I","slug":"筆記/shell/ShellScript-I","date":"2020-10-05T12:00:22.000Z","updated":"2021-05-12T09:41:24.392Z","comments":true,"path":"2020/10/05/筆記/shell/ShellScript-I/","link":"","permalink":"https://luomit.github.io/2020/10/05/%E7%AD%86%E8%A8%98/shell/ShellScript-I/","excerpt":"","text":"shell属于解释性高级语言，简单、跨平台能力强shell是linux自带的系统语言 shell用来做什么自动化批量系统初始化程序(系统安装、系统升级、软件安装、时区设置、安全策略等) 自动化部署或者运行程序(系统程序、桌面程序自动运行等) 日志分析 zabbix监控CPU80%+|-50% Python API AWS/EC2 shell特性 自动补全在shell输入过程中使用tab键可以获得脚本的提示和补全，加快代码编写效率；bash-completion Ubuntu已自动安装这个bash的自动补全扩展 历史命令的记录shell会记录执行过的命令，可以使用上下方向键调用或者使用history命令来查看 12345678history # 查看之前使用的所有命令history n # 查看最近的n个命令；这里的n是一个整数，表示查看历史记录数量history -d n # 删除历史记录中的第n个命令，将命令从记录中删除#!n # 执行第n个命令，用来直接执行历史记录中的命令#!-n # 执行历史记录中倒数第n条命令#!! # 执行历史记录中最后一条命令#!cd # 执行历史记录中最近已cd开头的shell命令history -c # 清除历史记录 别名功能alias命令，别名的好处就是可以把很长的指令简化缩写，用来提升工作效率 123alias # 查看当前系统的所有别名alias blog_edit=&#x27;code ~/.blog/_post&#x27; # 用编辑器打开博客文件夹unalias blog_edit # 取消这个blog_edit别名 这些如需要永久生效需要将他们写入到~/.bashrc配置文件中 bash的初始化bahs环境变量文件的加载 /etc/profile 配置文件 /etc/bashrc 系统配置 ~/.profile 用户配置 ~/.bash_login 登录时加载 ~/.bash_profile 用户配置 ~/.bashrc 用户配置 ~/.bash_logout 登出时加载 在linux系统启动时，bash会去加载环境配置文件，首先会加载全局配置文件再加载用户配置文件 在图形化界面登录时，会先读取/etc/profile再读取~/.profile;如果后者和前者的配置存在差异，后者会覆盖前者的配置 bash的特性bash快捷键 快捷键 作用 Ctrl+A 光标移动到开头 Ctrl+E 光标移动到结尾 Ctrl+C 强制终止命令 Ctrl+L 清屏 Ctrl+U 删除或剪切光标之前的命令 Ctrl+K 删除或见前光标之后的命令 Ctrl+Y 粘贴Ctrl+K或Ctrl+U剪切的内容 Ctrl+R 在历史命令中搜索 Ctrl+D 退出当前终端 Ctrl+Z 暂停并放入后台 Ctrl+S 暂停屏幕输出 Ctrl+Q 恢复屏幕输出 bash常见的几个作业命令1234567command &amp; # 执行命令后面加 &amp; ，让这个命令在后台运行 # Ctrl+Z 暂停并放入后台jobs # 查看后台作业状态fg %n # 将后台作业n切换到前台bg %n # 将前台作业n切换到后台kill %n # 将作业n移除kill -9 %n # 将作业n强制移除 注意这里的n不是pid进程id；这里的n时当前终端工作脚本程序的编号；这个编号从1开始分配；当一个工作完成或者移除后后，工作编号也会发生改变 bash输出重定向 类型 符号 作用 标准输出重定向 command&gt;file 以覆盖的方式,把command的正确输出结果输出到file文件中 command&gt;&gt;file 以追加的方式，把command的正确输出结果输出到file文件中 标准错误输出重定向 command 2&gt;file 以覆盖的方式,把command的错误输出结果输出到file文件中 command 2&gt;&gt;file 以覆盖的方式,把command的错误输出结果输出到file文件中 正确输出和错误输出同时保存 command&gt;file 2&gt;&amp;1 以覆盖的方式,把command的正确输出结果和错误输出结果输出到file文件中 command&gt;&gt;file 2&gt;&amp;1 以追加的方式,把command的正确输出结果和错误输出结果输出到file文件中 分别输出到不同文件 command&gt;file1 2&gt;file2 以覆盖的方式,把command的正确输出结果输出到file1文件中；把错误输出结果输出到file2文件中 command&gt;&gt;file1 2&gt;&gt;file2 以追加的方式,把command的正确输出结果输出到file1文件中；把错误输出结果输出到file2文件中 command&gt;file 2&gt;file [不推荐]这两种写法会导致file会被打开两次,引起资源竞争，所以stdout和stderr会相互覆盖 command&gt;&gt;file 2&gt;&gt;file [不推荐] command &amp;&gt;&gt;file [推荐]全部以追加的方式重定向到file文件中 输出重定向中, &gt;代表以覆盖的方式, &gt;&gt;代表以追加的方式；输出重定向的额完整写法时fd&gt;file,其中fd表示文件描述符，如果不写，默认为1，也就是标准输出文件；当文件描述符为1时，一般省略不写，如上表所示；当然也可以将 command&gt;file 写作 command 1&gt;file,但这样略显繁琐;当文件描述符大于1时，比如2，就必须写上;需要注意的时fd和&gt;之间不能有空个，否则shell会解析失败；&gt;和file之间的空格可有可无，但是为了避免出错，习惯性保持一致&gt;两边都不加空格;/dev/null 可以把不想显示的内容输入到这个文件里(相当于垃圾回收站) 1sl &amp;&gt;/dev/null bash输入重定向输入重定向就是改变输入的方向，不使用键盘作为命令输入的来源，而是使用文件作为命令的输入来源。 符号 说明 command&lt;file 将文件file作为command的输入 command&lt;&lt;END 从标准输入(键盘输入)中读取数据，直到读取到END字符才停止(分解符,可以时任意的字符串，用户可自定义的)。 file1 command file2 将file1作为command的输入，并将command的结果输出到file2中。 12cat readme.txt # 打印预览文件wc -l readme.txt # 输入重定向(统计文件行数) 总结: /dev/null 表示空的设备文件，无穷的大小，进入的文件不可再回收 0表示stdin标准输入 1表示stdout标准输出 2表示stderr标准错误 &gt;默认标准输出重定向，与 1&gt; 相同 2&gt;&amp;1意思是把 标准错误输出 重定向到 标准输出 &amp;file意思是把 标准输出 和 标准错误输出 都重定向到file中 &gt;&amp;file意思是把 标准输出 和 标准错误输出 都重定向到file中 shell中的特殊字符; 分号，连续运行多个命令1cat readme.txt;redame.txt&gt;&gt;/dev/null | 管道,正则表达式中表示或者123echo &quot;shell基础&quot; |egrep &#x27;(e|基)&#x27;&#123;2&#125; # 表示匹配 e 或者 基 字符ifconfig|grep eth0 # 表示ifconfig查处来的信息过滤出eth0这一行cat inputName.sh|grep &#x27;$name&#x27;&gt;about.txt # 过滤inputNmae.sh中带 $name 的行,并显示(cat)和重定向(&gt;)到about.txt &amp; 将命令放到后台执行12mysqld_safe --usr=mysql &amp; # 将mysql放到后台执行ifconfig &amp;&gt;/dev/null # 将ifconfig标准输出和标准错误输出重定向到/dev/null &amp;&amp; 前面命令返回值为0才执行后面的命令1ls &amp;&amp; echo &#x27;ok&#x27; # 执行ls结束后，返回 ok || 前面的命令返回值为0的时候才执行后面的命令12lls || echo &#x27;ok&#x27; # lls 不是shell命令，执行结果为0，输出 okls || echo &#x27;ok&#x27; # ls 是shell的命令，执行结果为真,不在执行||后面的命令 # 号,用来表示内容为注释123456echo $#a=&#x27;hello&#x27;echo $&#123;#a&#125; # 返回变量a的长度# $&#123;#变量名&#125;表示变量的长度# $# 表示位置参数的个数 ！ 惊叹号 将命令或者条件表达式返回值取反1if ![1&lt;2];then echo &#x27;ok&#x27;;else echo &#x27;no&#x27;;fi 不知道是书写规范问题还是什么，执行结果返回找不到那个文件和目录 $ 美元符号，取变量的值；在正则表达式中表示行尾12345a=10 # 定义变量aecho $a # 查看变量aegrep &#x27;:$&#x27; /etc/inittab # 打印 /etc/inittab 中以 : 结尾的行egrep &#x27;hello$&#x27; file # 打印 file 文件中以 hello 结尾的行 &gt; 大于号，输出重定向1echo &#x27;添加新的内容&#x27;&gt;test.txt # 将 添加新的内容 字符串以覆盖的方式添加到 test.txt 文件中 &lt; 小于号，输入重定向，条件测试中的小于号= 等于号，变量赋值条件测试中的等号(数值比较中的 == ) 123a=15 # 变量a赋值[a=b] # 判断变量a是否等于变量b(条件测试)((a==20)) # 判断变量a是否等于变量b(数值比较) + 加号算术运算符中的加号(1+3)正则表达式中表示一个或者多个前面的字符(a+bc 表示a和bc之间有1个字符) &gt;&gt; 输出重定向追加&lt;&lt; 输入重定向追加- 减号运算符中的减号命令的选项( ls -l )上一次的工作目录( cd - 前提是先要在上一个目录进行变量设置 set OLDPWD 否则会提示OLDPWD变量未设定)通配符和正则表达式中表示范围 [a-z] 12tar -cvf - /home | tar -xvf -# 表示输出或输入流，将前面的结果通过管道传递给后面作为对象进行操作 表示输出或输入流,将前面的输出 ，通过管道交给后面的命令，前面的压缩，后面的解压 ‘’ 单引号解决赋值空格的问题(a=’1 2’)阻止shell替换 “” 双引号和单引号一样的作用阻止shell部分字符替换，对$ ! 等无效 `` 反引号 相当于$()1a=`ls` # 命令行替换，设置变量a为shell命令ls % 百分号1echo $((100%10)) # 算术运算中的模运算 vi中替换操作中表示所有行(末行模式下，替换所有前面加%) 1%s/D/d 表示将文本中的所有的D替换为d ()单圆括号在子shell中执行命令，会继承父shell的变量. 命令的排序 &amp;&amp; || 具有逻辑判断的 ; (分号) 不具备逻辑判断，只用作链接两个命令的字符","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://luomit.github.io/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://luomit.github.io/tags/shell/"}]},{"title":"Houdini 外部编辑器安装配置","slug":"筆記/houdini/Houdini Python安装配置","date":"2020-03-30T00:51:04.000Z","updated":"2021-05-12T09:39:43.768Z","comments":true,"path":"2020/03/30/筆記/houdini/Houdini Python安装配置/","link":"","permalink":"https://luomit.github.io/2020/03/30/%E7%AD%86%E8%A8%98/houdini/Houdini%20Python%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Python环境配置Houdini Expr Editorhttp://cgtoolbox.com/ 下载并安装Houdini Expr Editor 安装方法将下载文件解压到houdini plugins文件内，然后在env环境变量中添加 1HOUDINI_PATH = &quot;/home/luomit/Sidefx_plugins/HoudiniExprEditor_v1_3_3/;&amp;&quot; Visual Studio Code下载安装vscode编辑器 配置插件vscode-icons #在vscode中的文件会根据不同格式显示为不同的文件图标Bracket Pair Colorizer #括号会根据对来分配随即颜色用于区分括号Highlight Matching Tag #高亮选中括号的另一端Auto Rename Tag #HTML自动匹配标签Path Intellisense #智能路径提示Material Theme #vscode皮肤主题Auto Import #代码补全Indent-Rainbow #对其颜色背景，根据缩进不同赋予不同颜色背景Prettier #代码格式化，美化你的代码书写格式Sublime Text Keymap and Settings Importer #sublime text 快捷键WakaTime #记录的的代码时光Code Runner #代码运行 Sublime Text 3下载 安装Sublime Text 3编辑器 安装包管理安装完成后Ctrl +Shift + P 键入Install Package Control安装包管理器 安装软件等待安装完毕后Ctrl +Shift + P 键入Install 就会有一项Package Control:Install Package的选项点击它，等待它再次弹出窗口时键入想要安装的插件名即可 常用插件 ConvertToUTF8SublimeTmplA File IconLocalizationSublimeTmplVEXBracketHighlighterMaterial ThemeAlignmentAutoFileNameSideBarWakaTime Houdini PythonEdit &gt; Preferences &gt; Set External Experssions Editor &gt; Double Click(双击)选择vscode程序;Ubuntu19使用whereis &quot;软件名&quot;查找软件安装路径如下 12luomit@luomit&gt;&gt;&gt; whereis code code: &#x2F;snap&#x2F;bin&#x2F;code.url-handler &#x2F;snap&#x2F;bin&#x2F;code Pyqt5 安装与配置pip查看pip3的版本 1pip3 -v 若是返回command not found: pip则执行下面一行代码安装pip3 1sudo apt-get install python3-pip pyqt5使用pip3安装pyqt5 1pip3 install pyqt5 安装其他的工具 123sudo apt-get install python3-pyqt5 sudo apt-get install pyqt5-dev-toolssudo apt-get install qttools5-dev-tools 配置环境使用终端运行 1qtchooser -run-tool=designer -qt=5 或者修改配置文件/usr/lib/x86_64-linux-gnu/qt-default/qtchooser/default.conf 12/usr/lib/x86_64-linux-gnu/qt5/bin/usr/lib/x86_64-linux-gnu 检查检验是否正确安装,创建一个uic.py的文件，内容如下 12345678#!/usr/bin/python3import subprocessimport syschild = subprocess.Popen([&#x27;pyuic5&#x27; ,&#x27;-x&#x27;,sys.argv[1]],stdout=subprocess.PIPE)print(str(child.communicate()[0],encoding=&#x27;utf-8&#x27;)) 参考","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"sublime text","slug":"sublime-text","permalink":"https://luomit.github.io/tags/sublime-text/"},{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"vscode","slug":"vscode","permalink":"https://luomit.github.io/tags/vscode/"}],"author":"luomit"},{"title":"Houdini python开发","slug":"筆記/houdini/houdini python开发","date":"2020-03-30T00:51:04.000Z","updated":"2021-05-12T09:41:37.417Z","comments":true,"path":"2020/03/30/筆記/houdini/houdini python开发/","link":"","permalink":"https://luomit.github.io/2020/03/30/%E7%AD%86%E8%A8%98/houdini/houdini%20python%E5%BC%80%E5%8F%91/","excerpt":"","text":"节点创建1234hou.pwd().createNode(&quot;sphere&quot;,name=&quot;球体&quot;) # hou.pwd()表示当前窗口所在工作路径 creatNode(节点原名，name=“设置新的名字”) hou.cd(&quot;/obj&quot;) # hou.cd() 移动当前窗口工作路径到指定的新路径上 节点删除12345node = hou.node(&quot;/obj/man/box1&quot;)node.destroy()# 先指定node为一个节点，再使用.destroy()来删除这个节点hou.node(&quot;cname&quot;).destroy()# 可以直接指定，直接删除 节点连线123456hou.node(&quot;merge1&quot;).setFirstInput(hou.node(&quot;sphere1&quot;))hou.node(&quot;merge1&quot;).setNextInput(hou.node(&quot;box1&quot;))# 假如我在geo1节点内创建了merge1、box1、sphere1三个节点，想要连接这三个节点# 首先确认当前窗口所在路径hou.pwd(),hou.cd(&quot;/geo1&quot;) 然后移动到geo1内# 再使用上面两行代码进行依次连接节点# setFirstInput设置地一个输入端接入连线，setNextInput设置下一个输入端连线 1有一样隐隐约约 断开节点123mer = hou.node(&quot;merge1&quot;)mer.setInput(0,None)# 设置merge1节点第一号输入端为None(断开) 父与子1234hou.parent(&quot;merge1&quot;)# 返回当前节点merge1的父级节点hou.node(&quot;.&quot;).children()# 返回当前节点下的所有节点","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"}],"author":"luomit"},{"title":"OpenColorIO","slug":"筆記/houdini/OpenColorIO-Configuration","date":"2020-03-28T07:20:31.000Z","updated":"2021-05-12T09:41:36.151Z","comments":true,"path":"2020/03/28/筆記/houdini/OpenColorIO-Configuration/","link":"","permalink":"https://luomit.github.io/2020/03/28/%E7%AD%86%E8%A8%98/houdini/OpenColorIO-Configuration/","excerpt":"","text":"准备视频教程下载 安装配置Houdini在文档中添加config.ocio的路径 1OCIO &#x3D; &quot;D:\\User\\luomit\\Documets\\OpenColorIO-Configs-master\\aces_1.0.3\\config.ocio&quot; Maya在 1Windows &gt; Setting&#x2F;Preferences &gt; Preferences &gt; ColorManagement &gt; OCIO Config Path 指定config.ocio的路径并启用Use OCIO Configuration Nuke 临时设置S键调出工程设置，在Color栏设置Color Management为OCIO就可以在项目中使用opencolorio 永久设置Edit &gt; Preferences &gt; Project Defaults &gt; Color Managment选择aces色彩空间点击OK保存即可 OpenColor基本工作流程1234567s&#x3D;&gt;start: 基础素材色彩空间处理o&#x3D;&gt;output: 输出到CG工作流程中i&#x3D;&gt;input: 导入CG渲染图像合成处理c&#x3D;&gt;convert: 转换为SRGB或其他适用的色彩空间格式e&#x3D;&gt;end: 转换为SRGB或其他适用的色彩空间格式s-&gt;o-&gt;i-&gt;c-&gt;e Nuke中的基础节点流1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162set cut_paste_input [stack 0]version 11.3 v5Read &#123; inputs 0 file_type png file F:&#x2F;Houdini&#x2F;Tree_Cloud&#x2F;model&#x2F;tree&#x2F;palm&#x2F;Sample_Palm&#x2F;Bark&#x2F;Palmetto_bark_2.png format &quot;1024 4096 0 0 1024 4096 1 &quot; origset true name Read7 label 渲染素材 selected true xpos 586 ypos 325&#125;OCIOColorSpace &#123; in_colorspace &quot;ACES - ACEScg&quot; out_colorspace &quot;Utility - sRGB - Texture&quot; name OCIOColorSpace3 selected true xpos 748 ypos 361&#125;Write &#123; file_type png checkHashOnRead false name Write2 label 渲染输出 selected true xpos 906 ypos 355&#125;Read &#123; inputs 0 file_type png file F:&#x2F;Houdini&#x2F;Tree_Cloud&#x2F;model&#x2F;tree&#x2F;palm&#x2F;Sample_Palm&#x2F;Bark&#x2F;Palmetto_bark_2.png format &quot;1024 4096 0 0 1024 4096 1 &quot; origset true colorspace sRGB name Read2 label 普通纹理 selected true xpos 65 ypos 312&#125;OCIOColorSpace &#123; in_colorspace &quot;Utility - sRGB - Texture&quot; out_colorspace &quot;ACES - ACEScg&quot; name OCIOColorSpace2 selected true xpos 222 ypos 355&#125;Write &#123; file_type exr first_part none name Write1 label 输出纹理到制作 selected true xpos 384 ypos 349&#125; Houdini&amp;Maya从Nuke中导入处理好的原始素材；纹理贴图、HDRI等进行CG创作输出ACES色彩空间的图像文件； Hexo流程图hexo使用流程图需要安装插件 1npm install --save hexo-filter-flowchart","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"opencolorio","slug":"opencolorio","permalink":"https://luomit.github.io/tags/opencolorio/"},{"name":"color","slug":"color","permalink":"https://luomit.github.io/tags/color/"}],"author":"luomit"},{"title":"PythonPJManegement","slug":"筆記/houdini/PythonPJMane","date":"2020-03-16T22:51:04.000Z","updated":"2021-05-12T09:41:34.683Z","comments":true,"path":"2020/03/17/筆記/houdini/PythonPJMane/","link":"","permalink":"https://luomit.github.io/2020/03/17/%E7%AD%86%E8%A8%98/houdini/PythonPJMane/","excerpt":"","text":"创建基础框架123456789101112131415161718192021222324from hutil.Qt import QtWidgetsimport osproj = hou.getenv(&#x27;JOB&#x27;)+&#x27;/&#x27;#使用hou.getenv获取当前工程的环境变量属性def openScene(item): hipFile = proj + item.data() hou.hipFile.load(hipFile) #print hipFiledef onCreateInterface(): widget = QtWidgets.QLabel(proj) listwidget = QtWidgets.QListWidget() #print &#x27;\\n&#x27; &quot;ProjectPath(&quot; + proj +&#x27;)&#x27; for file in os.listdir(proj): if file.endswith(&quot;.hip&quot;): listwidget.addItem(file) #将按钮链接到函数上执行打开文件的指令 listwidget.doubleClicked.connect(openScene) return listwidget","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"},{"name":"project","slug":"project","permalink":"https://luomit.github.io/tags/project/"},{"name":"manage","slug":"manage","permalink":"https://luomit.github.io/tags/manage/"}],"author":"luomit"},{"title":"Houdini安装与配置","slug":"筆記/houdini/Houdini安装与配置","date":"2020-03-06T10:58:48.000Z","updated":"2021-05-12T09:41:37.256Z","comments":true,"path":"2020/03/06/筆記/houdini/Houdini安装与配置/","link":"","permalink":"https://luomit.github.io/2020/03/06/%E7%AD%86%E8%A8%98/houdini/Houdini%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"","text":"安装下载官网下载也可以从国内各大CG论坛及素材网站下载如：filecr.com不科学上网不度盘直接下载速度快VFXFORCECCVFX书生CG资源站…官网下载流程演示https://www.sidefx.com/download/ 选这一种登录方式登录，如果你一种账号都没有就注册一个也是很快的。登录以后选择Get下的Downlode如下图然后直接点击Downlode下载，网页会根据你当前所使用的系统来下载当前最新稳定版本的软件；如果要下载指定版本可以滑到最下方可看见PRODUCTION BUILDSD点击选择你要下载的版本即可。 Windowswindous的安装网上很多也很简单[百度]https://jingyan.baidu.com/article/495ba841f5d02738b30ede23.html Linux根据上面的方法下载好后应该是以tag.gz结尾的压缩包如houdini-17.5.460-linux_x86_64_gcc6.3.tga.gz;解压到一个位置得到的文件如下所示然后使用终端 12cd /下载/houdini-17.5.460-linux_x86_64_gcc6.3/sudo ./houdini.install 终端会出现一系列的提示默认yes即可待续…. 配置外部编辑器配置参考本博客”Python环境配置“ houdini文档的配置(Windows)123456789101112131415161718192021222324252627# ---------------- &amp;&amp; Plug-ni PATH &amp;&amp; -------------------#自定义插件目录MEHOU &#x3D; D:\\Users\\luomit\\Documents\\houdini18.0\\plug-inMOPS &#x3D; $MEHOU&#x2F;MOPS-masterDM &#x3D; $MEHOU&#x2F;DM-v1.5.25HDRI &#x3D; $MEHOU&#x2F;Hdri-Link-for-Houdini-masterOPX &#x3D; $MEHOU&#x2F;optixARNOLD &#x3D; C:\\arnold\\htoa\\htoa-5.1.0_r9289183_houdini-$&#123;HOUDINI_VERSION&#125;\\htoa-5.1.0_r9289183_houdini-$&#123;HOUDINI_VERSION&#125;GAMETOOL &#x3D; $MEHOU&#x2F;SideFX_GameDevToolset_Houdini17.5_1.232EDITOR &#x3D; &quot;C:\\Users\\luomit\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe&quot;#PDG_IMAGEMAGICK &#x3D; &quot;C:\\luomitPC\\ImageMagick-7.0.9-Q16\\magick.exe&quot;#PDG_FFMPEG &#x3D; &quot;C:\\Program Files\\ffmpeg-20200227-9b22254-win64-static\\bin\\ffmpeg.exe&quot;---------------- &amp;&amp; Plug-ni PATH &amp;&amp; -------------------# --------------------- &amp;&amp; PATH &amp;&amp; -----------------------HOUDINI_PATH &#x3D; &quot;$HOUDINI_PATH;$GAMETOOL;$ARNOLD;$REDSHIFT;$MOPS;&amp;&quot;PATH &#x3D; &quot;$PATH;$EDITOR;$GAMETOOL&#x2F;bin;$ARNOLD&#x2F;scripts&#x2F;bin;$REDSHIFTPATH&quot;# --------------------- &amp;&amp; PATH &amp;&amp; -----------------------HOUDINI_BUFFERDSAVE&#x3D;1HOUDINI_UISCALE&#x3D;120HOUDINI_EXTERNAL_HELP_BROWSER&#x3D;1HOUDINI_USE_HFS_PYTHON&#x3D;1HOUDINI_DOS_ERROR&#x3D;2 houdini文档的配置(Linux)1234567891011121314151617181920212223# ---------------- &amp;&amp; Plug-ni PATH &amp;&amp; -------------------#自定义插件目录MEHOU &#x3D; D:\\Users\\luomit\\Documents\\houdini18.0\\plug-inMOPS &#x3D; $MEHOU&#x2F;MOPS-masterDM &#x3D; $MEHOU&#x2F;DM-v1.5.25HDRI &#x3D; $MEHOU&#x2F;Hdri-Link-for-Houdini-masterOPX &#x3D; $MEHOU&#x2F;optixARNOLD &#x3D; C:\\arnold\\htoa\\htoa-5.1.0_r9289183_houdini-$&#123;HOUDINI_VERSION&#125;\\htoa-5.1.0_r9289183_houdini-$&#123;HOUDINI_VERSION&#125;GAMETOOL &#x3D; $MEHOU&#x2F;SideFX_GameDevToolset_Houdini17.5_1.232# --------------------- &amp;&amp; PATH &amp;&amp; -----------------------HOUDINI_PATH &#x3D; &quot;$HOUDINI_PATH:$GAMETOOL:$ARNOLD:$REDSHIFT:$MOPS:&amp;&quot;PATH &#x3D; &quot;$PATH:$EDITOR:$GAMETOOL&#x2F;bin:$ARNOLD&#x2F;scripts&#x2F;bin:$REDSHIFTPATH&quot;# --------------------- &amp;&amp; PATH &amp;&amp; -----------------------HOUDINI_BUFFERDSAVE&#x3D;1HOUDINI_UISCALE&#x3D;120HOUDINI_EXTERNAL_HELP_BROWSER&#x3D;1HOUDINI_USE_HFS_PYTHON&#x3D;1HOUDINI_DOS_ERROR&#x3D;2 常用插件的配置Arnold 12PATH &#x3D; &quot;Arnold目录&#x2F;scripts&#x2F;bin;$PATH&quot;HOUDINI_PATH &#x3D; &quot;Arnold目录;&amp; Redshift 123HOUDINI_DSO_ERROR &#x3D; 2PATH &#x3D; &quot;C:&#x2F;ProgramData&#x2F;Redshift&#x2F;bin;$PATH&quot;HOUDINI_PATH &#x3D; &quot;C:&#x2F;ProgramData&#x2F;Redshift&#x2F;Plugins&#x2F;Houdini&#x2F;16.5.268;&amp;&quot; Deadline 12HOUDINI_PATH &#x3D; &quot;$HOUDINI_PATH;C:&#x2F;Users&#x2F;Administrator&#x2F;AppData&#x2F;Local&#x2F;Thinkbox&#x2F;Deadline10&#x2F;submitters&#x2F;HoudiniSubmitter;&amp;&quot;HOUDINI_MENU_PATH &#x3D; &quot;$HOUDINI_MENU_PATH;C:&#x2F;Users&#x2F;Administrator&#x2F;AppData&#x2F;Local&#x2F;Thinkbox&#x2F;Deadline10&#x2F;submitters&#x2F;HoudiniSubmitter;&amp;&quot; Qlib下载 1git clone https://github.com/qLab/qLib.git 1234QLIB &#x3D; &quot;$MEHOU\\qLib-master\\&quot;QOTL&#x3D; &quot;$QLIB&#x2F;otls&quot;HOUDINI_OTLSCAN_PATH &#x3D; &quot;$QOTL&#x2F;base;$QOTL&#x2F;future;$QOTL&#x2F;experimental;$HOUDINI_OTLSCAN_PATH;&amp;&quot;HOUDINI_PATH &#x3D; &quot;$QLIB;&amp;&quot; GameDevelopment下载 1git clone https://github.com/sideeffects/GameDevelopmentToolset.git 12HOUDINI_PATH &#x3D; C:\\Users\\Luiz\\Documents\\GameDevelopmentToolset;&amp;PATH &#x3D; C:\\Users\\Luiz\\Documents\\GameDevelopmentToolset\\bin;$PATH 关于h18复制粘贴报错在某群有群友上传这里做个备份，需要的朋友自取文件下载将两个dll复制到安装目录下替换即可 未完…","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"}],"author":"luomit"},{"title":"Houdini Solaris 基础","slug":"筆記/houdini/Solaris基础(一)","date":"2020-02-22T04:06:44.000Z","updated":"2021-05-12T09:41:34.301Z","comments":true,"path":"2020/02/22/筆記/houdini/Solaris基础(一)/","link":"","permalink":"https://luomit.github.io/2020/02/22/%E7%AD%86%E8%A8%98/houdini/Solaris%E5%9F%BA%E7%A1%80(%E4%B8%80)/","excerpt":"","text":"基础概念USD基础知识即Solaris流程框架概述USD是Universal Scene Description的缩写，译通用场景描述；是皮克斯开发的一个文件格式。USD的优点: 树状分层描述场景数据，结构清晰，管理方便灵活。 分层(Layer)组织数据，强大的数据合成机制，实现非破坏性编辑。 多层嵌套引用机制，实现轻量化存储，场景载入效率极高。 基于Hydra渲染架构，实现大量集合体场景的高效预览。 Solaris是Houdini新增的新模块，是houdini为USD所提供的工具和支持的统称。Solaris模块在houdini中的主要工作层级是LOP(Light Operator);在LOP层级中，Stage指代当前正在操作的整个场景。USD基础知识点: USD中对象的基本单位是Primitive(不同与SOP中的Primitive,这里的一个Primitive通常指代一个对象) USD文件的两种编码格式 二进制格式.usd(.usdc)(体积小,方便调用) 文本格式.usda(有层级结构，方便使用文本编辑器打开查看) Solaris模块基础操作讲解Solaris在houdini中可以在Network层级和sop层级创建，也可以直接在Network View切换到Solaris，在Network和sop中创建时它的名字为LOP Network。在Solaris中资产的创建和导入有多种方式: SOP Import 节点导入sop层级创建的资产(SOP Path指定sop路径；Primitive Path指定导入对象在场景中的位置路径…) Scene Import 节点导入方式和SOP Import类似，但是也有不同之处… SOP Create 该节点相当于在Solaris创建了一个SOP Network，然后在里面创建资产 也可以直接创建一些简单的几何体对象，如Sphere、Box等(直接创建的对象都是usd对象，不可编辑集合体顶点) Scene Graph Path大纲、场景树状结构图Primitive Type对象类型Primitive Kind类别、性质、组、单位Primitive Path只是更改当前对象在SceneGraphPath(场景树状结构层级)中的位置;这个路径不能为空，也不能直接是/根(通俗讲SceneGraphPath相当于村地图，Primitive Path应该是指定从村口去到你家路线，途中可能会经过邻居家)Import Path Prefix指定导入模型对象在Scene Graph Path中的路径;与Primitive Path都是用来指定路径，但是Primitive Path会叠加在Import path prefix前并且会替换调import path prefix指定路径的最顶层(如primpath指定的是/mail,importpath指定的是/box/acc，最终得到的是/mail/acc的路径),所以这项参数至少设置两层以上才有作用SOP Path Attribute用来指定导入对象最里面那一层的名字，默认是根据name属性设置，如果没有nane属性且导入的不是sphere primitive那名字就是mesh_0；如果导入的sphere primtive，那名字就是sphere_0;导入的如果是体积且没有name属性，那名字就是field_0Make Instanceable在需要复制大量对象是启用可以提高运行效率 选项 实例 子层级Kind Assembly BookShelfShelfBookA……BookZ AssembleGroupComponent Group CupsCup0Cup1……Cup10 AssemblyGroupComponent Component Shelf / BookA / Cup1 SubComponent SubComponent BookABook_MeshCup0Cup_BodyCup_Liq Configureprimitive 设置指定路径对象的Kind在场景中，Kind不去设置不会影响场景的有效性，但是规范的kind层级可以在复杂场景进行遍历计算时有着良好的运行效率(不包含灯光材质)； Inlineusd 可以通过写usd脚本创建usd文件，或者粘贴usd脚本实现usd的重建(导入)Sublayer 从硬盘导入usd文件或从场景(连线)导入(一个或多个)文件，在导入多个文件时，如果导入的usd的SceneGraphPath相同，就会根据SublayerPosition来选择覆盖Reference 从硬盘导入usd文件或从场景(连线)导入(一个或多个)文件，并且可以修改导入文件的PrimitivePath、Kind等参数 以下问题将在下一解课中详细解释: 该如何理解层的概念？层在实际制作中的意义是什么？ 数据合成机制是如何运作的？Sublayer和reference有哪些具体区别？ 激活层(Active Layer)是什么意思？ 展平层(Flattem Layers)是什么意思？ 层的输出路径有什么作用？如何设置输出路径？ 输出节点的Save Style参数有什么作用？ 层与数据合成机制深入探究USD-ROP 分层输出机制分析 实操演练创建USD资产sopimport从sop导入资产数据，如果资产数据带有name属性，就会在SceneGraphPath中根据name分成多个Primitive;sopimport资产通常占用较大的存储空间，可以在sopimport下的LayerSavePath中指定该层的存储路径;PrimitivePath在设定时注意上下层级之间最好不要有重名，不然会在其他节点上出现报错，甚至节点网络无法工作;在USD资产创建时，如果使用到Prune对上游资产进行操作时，操作的对象不能勾选MakeInstanceable在为资产创建变体时，variantblok_end的PrimitivePath要设置到主体个层级上，这样就不会产生多余的SceneGraphPath层了。在usd资产导出前检查整理SceneGraphPath里的层级和属性，使用configureprimitive为资产设置合理的Kind，使用ConfigureLayer为需要单独设置保存路径的资产设置保存路径。总结: 模型的处理，需要注意的时模型在创建usd资产过程中需不需要制作变体，模型有没有组信息(name)，没有就添加；模型是否在世界坐标中心，这个视具体情况而定，通常要把物体设置到世界坐标中心(matchsize); 在stage内引入sop资产时，通常会勾选Load As Reference(导入物体通常较大,单独设置保存独立的usd文件)有利于资产的管理和调用; 在设置变体时，需要注意变体的PrimtivePath一定要设置合理，不然会导致调用变体时查找不到变体集的路径; 材质和灯光通常也会单独输出(configurelayer设置单独的存储路径)，根据具体项目进行调整; 装配USD资产stagemanager 用来搭建场景,可以方便快速的在场景白方资产文件; Layout场景搭建分镜资产制作简单动画制作特效制作灯光和渲染","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"usd","slug":"usd","permalink":"https://luomit.github.io/tags/usd/"},{"name":"Solaris","slug":"Solaris","permalink":"https://luomit.github.io/tags/Solaris/"}],"author":"luomit"},{"title":"Ubuntu20.04 Linux初识","slug":"筆記/linux/Ubuntu20.04Linux基础学习","date":"2020-02-22T04:06:44.000Z","updated":"2021-05-12T09:41:32.489Z","comments":true,"path":"2020/02/22/筆記/linux/Ubuntu20.04Linux基础学习/","link":"","permalink":"https://luomit.github.io/2020/02/22/%E7%AD%86%E8%A8%98/linux/Ubuntu20.04Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"=====进阶轨迹 Ubuntu简述Ubuntu是常见的三大操作系统Windows、Mac、Linux中，linux的其中一个发行版；linux系统有着种类繁杂的发行版，其中RedHet、CentOS、Ubuntu、Debian、Deepin(国人开发)等。Linux主要应用于服务器操作系统，它相对与Windows更加的稳定和安全。 系统文件结构linux 系统文件结构为目录树结构， 123456//home/vfx/root/bin/mnt/etc / 根目录，类似与windows的C盘，linux的/根目录包含其他所有的目录，是其他目录的父级。 /home/vfx 用户文件夹,在home下每当创建一个用户，都会创建一个用户文件夹，当前用户是fx。 /root 管理员文件夹，每个系统都有一个管理员，该用户拥有当前系统的最高权限。 ...... linux文件的权限机制有利与保护系统的安全，避免用户的误操作。 对于普通用户来说，能够操作和修改的文件仅限于当前用户的文件，管理员则可以管理包括系统文件在内的所有文件。 常用的命令 cd ls cp rm tarls,list的缩写，列出目录下的所有项(包括文件和文件夹)例：列出home下fx用户的所有项 1ls /home/vfx 模板 图片 下载 桌面 snap公共的 视频 文档 音乐 Documents tips: 在linux终端操作时可以使用Tab来补全未写全的命令，使用上下健来获取操作命令历史。 pwd,即print working directory显示打印当前的工作目录。cd 切换目录，切换或改变当前操作执行在系统目录中的位置。例:切换到home下的vfx目录下 1cd /home/vfx tips: linux的几个特殊的目录： ～ 代表当前用户的主目录 . 代表当前目录 .. 代表上一级目录 cd ～ 切换到主目录 cd ~/home 切换到主目录下home目录下 cd ../maxman 切换到上一级目录下一个名字叫maxman子目录下 mkdir,make directory创建目录(文件夹)例：创建一个名字为python的文件夹 1mkdir python 例：在home下创建一个名字为maxman的文件夹 1mkdir /home/maxman 创建多层文件夹（一次性创建多个层级嵌套的文件目录树） -p 1mkdir -p /new/max/man rm,即remove删除文件或者目录例：删除maxman目录 1rm -rf maxman 这里的r表示recursive递归删除，f便是force强制删除（谨慎使用） cp,即copy复制文件或目录例：复制maxman到用户目录下 1cp -rf maxman /home/vfx mv,即move移动文件或目录(重命名)例:重命名maxman为houdini 1mv maxman houdini 这是manman目录就会变为houdini，如果houdini已经存在，则自动变为houdini1或者houdini… tar,即tape archive档案打包、创建档案包1tar -cvf maxman.tar maxman -cvf打包，其中c表示create创建档案，v表示verbose显示详情，f表示文件也可以一次打包多个文件”tar -cvf xxx.tar file0 file1 file2” 1tar -xvf maxman.tar -C /home/manman -xvf解包，其中-C(大写)用来指定解包后文件要存放的地址，不指定默认解包到当前目录下 归档并压缩 -cfx -xvf 只是对文件目录进行打包和解包，没有对文件进行压缩；-czvf -xzvf 则是在打包或解包时同时对文件进行压缩和解压缩处理；通常所见到的*.tar.gz格式就是压缩打包形式 ln 软链接，即windows下的”快捷方式”使用ln命令(link)来创建软链接ln -s source link其中,-s表示soft软链接(默认为硬) 1ln -s maxman /home/vfx/桌面/manman 连接maxman到桌面的maxman 文本编辑器 vi geditvi/vim,是一个基于控制台的文本编辑器，vim是vi的升级版gedit，是一个基于GUI的文本编辑器 1vim name.txt #打开name.txt文件，如果该文件存在则打开编辑，如果不存在则创建后打开 如果系统上没有vim,可以使用”sudo apt install vim”安装 vim的基本用法模式的切换编辑模式Insert Mode 按键盘i键进入命令模式Command Mode 按键盘ESC键进入保存和退出命令:wq 保存并推出:q 退出:q! 强制退出:qw! 强制保存退出 vim的更多用法vim 是一个全键盘操作的文本编辑器，工作效率比较底，掌握基本的用法即可，如果需要了解更多复杂的操作可以到网络上临时搜索用法即可 本人推荐使用vscode简单、强大、漂亮 用户及权限系统 chmodUbuntu用户管理添加用户 1sudo useradd -m username sudo表示使用管理员的身份执行操作，-m表示在/home下添加用户目录删除用户 1sudo userdel username 修改用户密码 1sudo passwd username 除了管理员，还有特殊用户和普通用户的区别，区别在于特殊用户可以在命令前加sudo来暂时使用管理员权限，普通用户则不可以；能使用sudo权限的用户为sudoer 超级管理员首次使用root用户需要设置管理员密码 1sudo passwd root 切换到root用户 1su root su表示switch user 退出管理员权限 1exit 文件的权限1ls -l -rwxrwxrwx drwxrwxr-x使用ls -l 可以列出文件的权限信息，列出的字符中前面的十个字符第一个(红色)表示文件类型，-表示文件，d表示目录，l表示链接；然后剩下的九个三个为一组分别表示当前用户的权限、同组用户对该文件的权限、其他用户对该文件的权限；r表示可读，w表示可写，x表示可执行，每一组都用rwx来表示权限，-表示权限禁止；rxw可读可写可执行 rx-可读可写不可执行 r–可读不可写不可执行 —不可读不可写不可执行 文件权限的修改chmod,即change file mode 修改文件的访问权限比如，一个文件想让其他用户可写 1chmod o+w file 其中，o表示其他人；+w表示增写write权限；-w表示除去写入write权限a表示所有人；u表示当前用户；如果w前不指定对象，则表示应用与当前用户及其所在组用户的权限 修改文件的属主chown，即change owner修改文件的属性一般来说，每个用户都只对自己的文件进行操作，很少使用到这个命令 1chown -R vfx /opt/maxman 将/opt/maxman目录（-R及其子目录）的属主改为vfx用户 shell脚本入门 .sh脚本Script，一种解释执行的程序。Linux下常见的三种脚本程序-shell脚本 *.sh-Pell脚本 *.pl-Python脚本 *.py shell脚本，是linux自带的脚本语言，类似与windows下的dos批处理脚本 12#!/bin/shecho &quot;hello,world&quot; 一个简单的打印hello world的shell脚本 1chmod +x hello.sh 添加执行权限 1./hello.sh 执行shell脚本 书写shel脚本时第一行要声明(#!/bin/sh)解释器,要拥有执行权限才可执行 shell中的变量典型的环境变量，PATH，JAVA_HOME 定义变量1234#!/bin/shOUTDIR=/opt #定义变量echo&quot;output to : $&#123;OUTDIR&#125;&quot; #使用变量ls $&#123;OUTDIR&#125; 定义变量NAME=alue等号的左右两侧不要有空格使用${NAME}来调用变量，如果有定界符，则可以简写为$NAME,例如 echo ${NAME}/build常用命令 exho打印 ls列出目录 cd跳转位置 cp复制文件目录if逻辑判断 while循环逻辑 环境变量123export OUTDIR=/opt #环境变量的定义echo $&#123;OUTDIR&#125; #显示环境变量printenv #显示当前系统的所有环境变量 在命令行中定义的环境变量，只有对当前shell终端有效；当终端关闭、重启后消失； 用户环境变量tips:使用&quot;ls -a&quot;可以查看当前目录下的所有文件(包括隐藏文件) 123gedit ~/.profile #打开.profile用户隐藏文件件export PLUGIN_PATH=/opt/houdini_plugin #添加自定义变量到.profile内echo $PLUGIN_PATH #注销或重启系统后生效 通过.profile添加的环境变量，对当前用户有效，每个有户都有自己的.profile文件；有的linux系统中使用的是.bash_profile文件 系统环境变量 系统环境变量定义在”/etc/profile”文件中，在这里定义的环境变量对当前系统下的所有用户有效 123sudo gedit /etc/profile #一般不会直接修改/etc/profile,而是在/etc/profile.d创建一个自定义的脚本sudo gedit /etc/profile.d #添加自定义全局变量到/etc/profile.d目录下sudo gedit /etc/profile.d/new.sh #创建一个名字为new.sh的脚本，在上面添加自定义全局变量export PATH=/opt/hfs18.5.358 注销重启后生效 linux中的PATH环境变量PATH，最常见的一个环境变量，用于描述可执行程序的搜索路径 1echo $PATH #显示当前系统PATH环境变量 /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin每个路径用冒号隔开 12#!/bin/shexport PATH=$PATH:/opt/houdini_plugin 这里$PATH引入当前已有的变量，不引入会覆盖之前的PATHsbin目录下的为超级管理员root才可以执行的程序/usr/下是系统自带的程序/usr/local/下是用户安装的程序 ubuntu中手动配置网络1ifconfig #查看当前网络配置，默认系统没有安装”sudo apt install net-tools“ ifconfig会列出当前系统所有的网络接口及接口的状态信息，其中if表示interface网络接口;第一行冒号前面的字符就是网络接口的名字 12sudo ifconfig xxxx up #开启网络接口sudo ifconfig xxxx down #关闭网络接口 常见的服务器 vsftpd在部署网站等需要使用到云服务器操作时，都会将本地的文件上传到云服务器上，这时就需要使用网络传输的方式将文件部署到云端。网络传输一般有FTP、SFTP两种方式。 FTP服务器客户端 FileZilla(Windows)服务器 vsftpd(Ubuntu)略…… SFTP服务器使用Xshll远程登陆使用Xftp传输文件略…… 文本文件的上传文本文件的换行符Windows: \\r\\nLinux: \\n Java/Tomcat运行环境的搭建等Linux程序与进程程序Program:指一个程序文件,如houdini.exe进程Process:但一个程序在系统上运行是，系统会创建一条用来描述程序运行状态的记录，这个记录就叫做进程 ps -ef查看系统所有进程 User执行者，PID进程ID，PPID父进程ID，STIME启动时间，CMD启动时调用的命令行 1234ps -ef | grep houdini #vfx 43668 1538 82 11:56 ? 00:00:13 /opt/hfs18.5.351/bin/houdinifx-bin#vfx 43738 39606 0 11:57 pts/0 00:00:00 grep (省略) -dir=.tox houdini 按名字查找进程，”ps -ef”将读取的信息输出，重定向给”grep”命令进行过滤处理 ps -ef | grep xxxx 常用命令，必记 使用top命令动态查看系统进程 1top 按上下键翻阅或者PaUp和PaDn翻页预览按q或者CLRT+C终止退出 12top | grep houdini #查看houdini动态进程top - p 43668 #&quot;top -p PID&quot;可以查看进程详细的使用状态 top -p xxxx 常用命令，必记 使用kill杀死终结系统进程 1kill -9 PID #PID进程id号，使用&quot;ps -ef&quot;查看 使用pkill查找并杀死终结系统进程 Ctrl+C 终止进程 前台进程与后台进程差异1：有无控制台前台进程，有控制台，运行结果输出至当前终端后台进程，无控制台，看不到输出(运行状态)差异2：有无父进程前台进程，有父进程，父进程即当前终端；当终端关闭时，进程被一同关闭后台进程，有父进程，父进程为系统进程(1号进程);当终端关闭时，后台进程不受影响 xxxx run以前台方式运行xxxx start以后台方式运行 其他软件的编译与安装 RedisMySQL服务器安装MySQL跨平台，”免费”MariaDB是MySQL的免费开源版本MySQL安装配置 特别感谢阿发你好提供的学习资料","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://luomit.github.io/tags/ubuntu/"}],"author":"luomit"},{"title":"Nuke 基础","slug":"筆記/nuke/Nuke11","date":"2020-02-22T04:06:44.000Z","updated":"2021-05-12T09:41:28.999Z","comments":true,"path":"2020/02/22/筆記/nuke/Nuke11/","link":"","permalink":"https://luomit.github.io/2020/02/22/%E7%AD%86%E8%A8%98/nuke/Nuke11/","excerpt":"","text":"Nuke的基本操作","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"nuke","slug":"nuke","permalink":"https://luomit.github.io/tags/nuke/"}],"author":"luomit"},{"title":"Nuke 技巧","slug":"筆記/nuke/Nuke技能(一)","date":"2020-02-22T04:06:44.000Z","updated":"2021-05-12T09:41:28.370Z","comments":true,"path":"2020/02/22/筆記/nuke/Nuke技能(一)/","link":"","permalink":"https://luomit.github.io/2020/02/22/%E7%AD%86%E8%A8%98/nuke/Nuke%E6%8A%80%E8%83%BD(%E4%B8%80)/","excerpt":"","text":"nuke中的扭曲效果(能量、热浪、波纹)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192set cut_paste_input [stack 0]version 12.1 v1push 0push $cut_paste_inputGroup &#123; inputs 2 name User-IDistort selected true xpos 862 ypos -117 addUserKnob &#123;20 User&#125; addUserKnob &#123;41 uv_scale l &quot;UV scale&quot; T IDistort1.uv_scale&#125; addUserKnob &#123;41 size l &quot;Blur size&quot; t &quot;Blur Size&quot; T Blur4.size&#125;&#125; Input &#123; inputs 0 name Channal note_font_color 0xc6653bff xpos 209 ypos 206 &#125; Blur &#123; size 9.2 name Blur4 xpos 209 ypos 246 &#125;set Na9f42a20 [stack 0] Emboss &#123; Angle 90 name Emboss2 xpos 348 ypos 341 &#125;push $Na9f42a20 Emboss &#123; name Emboss1 xpos 209 ypos 337 &#125; Merge2 &#123; inputs 2 operation plus Achannels &#123;rgba.red -rgba.green -rgba.blue rgba.alpha&#125; Bchannels &#123;-rgba.red rgba.green -rgba.blue rgba.alpha&#125; output &#123;rgba.red rgba.green -rgba.blue rgba.alpha&#125; name Merge4 xpos 209 ypos 441 &#125; Grade &#123; channels &#123;rgba.red rgba.green -rgba.blue none&#125; blackpoint 0.5 whitepoint 0.5 black 0.06 black_clamp false name Grade1 xpos 209 ypos 518 &#125; Input &#123; inputs 0 name Source note_font_color 0x80a33fff xpos 11 ypos 472 number 1 &#125; Copy &#123; inputs 2 from0 rgba.red to0 forward.u from1 rgba.green to1 forward.v name Copy1 xpos 11 ypos 512 &#125; IDistort &#123; uv forward uv_scale 3.6 name IDistort1 xpos 11 ypos 605 &#125; Output &#123; name Output1 xpos 11 ypos 693 &#125;end_group 教程链接","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"nuke","slug":"nuke","permalink":"https://luomit.github.io/tags/nuke/"},{"name":"function","slug":"function","permalink":"https://luomit.github.io/tags/function/"}],"author":"luomit"},{"title":"PyQt菜单与工具栏","slug":"筆記/python/PyQt菜单与工具栏","date":"2020-02-22T04:06:44.000Z","updated":"2021-05-12T09:41:27.818Z","comments":true,"path":"2020/02/22/筆記/python/PyQt菜单与工具栏/","link":"","permalink":"https://luomit.github.io/2020/02/22/%E7%AD%86%E8%A8%98/python/PyQt%E8%8F%9C%E5%8D%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E6%A0%8F/","excerpt":"","text":"QMainWindow创建基本窗口123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import sysfrom PyQt5.QtWidgets import QMainWindow,QApplicationclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.statusBar().showMessage(&#x27;Ready&#x27;) #QMainWindow类第一次调用ststusBar()方法创建一个状态栏，后续调用返回状态栏对象，showMassage()状态栏上显示一条消息 self.setGeometry(300,300,250,150) self.setWindowTitle(&#x27;Statusbar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())```` ### 创建菜单栏````pythonimport sysfrom PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): exitAction = QAction(QIcon(&#x27;bi.svg&#x27;), &#x27;&amp;Exit&#x27;, self) #定义菜单控件图标与名字 exitAction.setShortcut(&#x27;Ctrl+Q&#x27;) #定义控件快捷键 exitAction.setStatusTip(&#x27;Exit application&#x27;) #定义控件提示 exitAction.triggered.connect(qApp.quit) self.statusBar() # 创建一个菜单栏 menubar = self.menuBar() # 添加菜单 fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) # 添加事件 fileMenu.addAction(exitAction) #点击菜单控件的时候，调用qApp.quit,终止应用程序 self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Menubar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 123456789101112131415161718192021222324252627282930313233343536373839import sysfrom PyQt5.QtWidgets import QMainWindow, QAction, QTextEdit, QApplicationfrom PyQt5.QtGui import QIconclass Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): textEdit = QTextEdit() self.setCentralWidget(textEdit) exitAction = QAction(QIcon(&#x27;bi.svg&#x27;), &#x27;Exit&#x27;, self) exitAction.setShortcut(&#x27;Ctrl+Q&#x27;) exitAction.setStatusTip(&#x27;Exit application&#x27;) exitAction.triggered.connect(self.close) self.statusBar() # 创建一个菜单栏 menubar = self.menuBar() # 添加菜单 fileMenu = menubar.addMenu(&#x27;&amp;File&#x27;) # 添加事件 fileMenu.addAction(exitAction) #添加工具栏并命名为Tool，点击也是执行退出操作 toolbar = self.addToolBar(&#x27;Tool&#x27;) toolbar.addAction(exitAction) self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Menubar&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 信号与信号槽所有的GUI程序都是事件驱动的。事件由用户出发，但也有可能是其他触发方式；例如网络连接、windows manager或定时器。当我们调用QApplication的exec_()方法时会使程序进入主循环，主循环会获取并分发时间。在事件模型中，有三个参与者；分别是事件源、事件对象、时间接收者。事件源是状态发生的对象，时间(对象)封装了事件中状态的变动，事件接收者是要接受事件源材料的对象，事件源对象将事件的处理工作交给事件接收者。 PyQt5有独特的signal&amp;slot(信号槽)机制来处理事件，信号槽用于对象间的通信；signal在某以特定事件发生时被触发，slot可以是任何callable对象；当signal触发时会调用与之相连的slot。 信号槽Signal&amp;slots1234567891011121314151617181920212223242526272829303132import sysfrom PyQt5.QtWidgets import (QWidget, QApplication, QVBoxLayout,QLCDNumber,QSlider)from PyQt5.QtCore import Qt class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): lcd = QLCDNumber(self) sld = QSlider(Qt.Horizontal, self) vbox = QVBoxLayout() vbox.addWidget(lcd) vbox.addWidget(sld) self.setLayout(vbox) sld.valueChanged.connect(lcd.display) #calueChanged参数关联到lcd显示插槽上 #sender是发出信号的对象。receiver是接收信号的对象。slot(插槽)是对信号做出反应的方法。 self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Signal &amp; slot&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 重写实现事件处理器1234567891011121314151617181920212223import sysfrom PyQt5.QtWidgets import QWidget, QApplicationfrom PyQt5.QtCore import Qtclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300,300,250,150) self.setWindowTitle(&#x27;Event handler&#x27;) self.show() def keyPressEvent(self,e): if e.key() == Qt.Key_Escape: self.close()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 链接槽函数1234567891011121314151617181920212223242526272829303132333435363738394041424344import sysfrom functools import partial#import pymel.core as pm #maya的pyme模块提供了一种槽信号的链接方法，如需要使用需要导入此库from PyQt5.QtWidgets import*from PyQt5.QtGui import *from PyQt5.QtCore import *def fn(): print(123)def func(v): print(v)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) btn = QPushButton() # 1 btn.clicked.connect(fn) # 2 btn.clicked.connect(lambda :fn()) # 3 btn.clicked.connect(partial(fn)) # 4 # import pymel.core as pm # btn.clicked.connect(pm.Callback(fn)) #pymel的槽函数链接方法演示 # 1 btn.clicked.connect(lambda:func(456)) # 2 btn.clicked.connect(partial(func,456)) # 3 # btn.clicked.connect(pm.Callback(fn,456)) # maya pymel.core.Callback for i in range(5): btn.clicked.connect(lambda:func(i)) for i in range(5): btn.clicked.connect(partial(func,i)) btn.show() sys.exit(app.exec()) 以上代码演示了几种不带参数的槽函数的用法和几种带参数的用法，一般情况下不带参数建议使用lambda方法链接槽函数，其他情况建议使用partial方法不易出现错误的情况。","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://luomit.github.io/tags/PyQt5/"}],"author":"luomit"},{"title":"Python基础(01)","slug":"筆記/python/Python基础(01)","date":"2020-02-22T04:06:44.000Z","updated":"2021-05-12T09:41:26.578Z","comments":true,"path":"2020/02/22/筆記/python/Python基础(01)/","link":"","permalink":"https://luomit.github.io/2020/02/22/%E7%AD%86%E8%A8%98/python/Python%E5%9F%BA%E7%A1%80(01)/","excerpt":"","text":"Python编程介绍 01本节目标：学习了解Python语言在当今社会的现状及其未来的发展前景，及对本次课程的总体介绍；本章作为学习笔记记录学习状态 百度百科：Python是一种计算机程序设计语言。是一种面向对象的动态类型语言，最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越来越多被用于独立的、大型项目的开发。IT为Information Technology（信息技术）的简写，又可引申为信息技术行业的简称。IT行业主要包含计算机和通信方面的知识，若想涉足IT行业一般需要掌握信息获取、处理的基本理论和应用的方法。 Python的起源 Python由Guidi（龟叔）于1989年处于娱乐性目的开发；Python语言基于ABC教学语言。 Python上手简单学习成本低，因此比较收到非编程专业领域的人的青睐；它还常用应用于医学、建筑、艺术等其他专业。 Python的历史 2008年12月，Python发布3.0版本(也常被称为Python3000、或简称Py3k )，因为3.0和2.x不兼容，所以Python在较长的一段时间内都没有过度的3.0；Python官方称2.x将维护至2020年，所以可以早些接触Python3.x;Houdini的Python3.x测试版本也将在2019年底退出(小笔记小笔记，也不知准不准确，期待期待！！) Python的应用领域 运维自动化：目前Python主要应用的领域 大数据处理、数据分析：Python通过丰富多样的库来轻松完成数据分析 网络爬虫、数据爬取：使用Python开发快速、简洁（人生苦短，我用Python） Web后端开发：Python也可以处理，Python提供大量后端框架，便于后端的开发 机器学习人工智能（AI）:Python火热的主要原因,了解人工智能就能够理解Python受宠的原因： 百度百科：人工智能的核心算法是完全依赖于C/C++的，因为是计算密集型，需要非常精细的优化，还需要GPU、专用硬件之类的接口，这些都只有C/C++能做到。所以某种意义上其实C/C++才是人工智能领域最重要的语言。Python是这些库的API binding，使用Python是因为CPython的胶水语言特性，要开发一个其他语言到C/C++的跨语言接口，Python是最容易的，比其他语言的ffi门槛要低不少，尤其是使用Cython的时候。其他语言的ffi许多都只能导入C的函数入口点，复杂的数据结构大多只能手工用byte数组拼起来，如果还需要回调函数输入那就无计可施了。而CPython的C API是双向融合的，可以直接对外暴露封装过的Python对象，还可以允许用户通过继承这些自定义对象来引入新特性，甚至可以从C代码当中再调用Python的函数（当然，也有一定的条件限制）。不过这也是PyPy这样的JIT解释器的一个障碍。而且Python历史上也一直都是科学计算和数据分析的重要工具，有numpy这样的底子，因为行业近似所以选择API binding语言的时候会首选Python，同时复用numpy这样的基础库既减少了开发工作量，也方便从业人员上手。&lt; Python数据类型Python的变量 Python具有如下两个特征： 变量无需声明即可直接赋值，对一个不存在的变量赋值就相当于定义了这个变量 变量的数据类型可以动态变化，同一个变量可以赋予不同类型的值，会存储最新赋予的值 Python标识符的规则 Python区分大小写 标识符可以有字母、数字、下划线( _ )组成，其中不能使用数字开头 标识符不能是Python关键字，但可以包含关键字 标识符不能包含空格 Python整型 Python3的整型支持各种整数值，不管识小的整数，还是大的整数，Python都可以轻松处理(Python2x使用long处理数值过大的整型） 整形的四种表现形式 十进制：最普通的整数就是十进制的整数 二进制：以0b或者0B开头的整数就是二进制的整数 八进制：以0o或者0O开头的整数就是八进制的整数 十六进制：以0x或0X开头的整数就是十六进制的整数 Python浮点 浮点型数值用于保存带小数点的数值，Python的浮点数有两种形式 十进制数形式：这种形式就是平常简单的浮点数 科学计数形式：例如5.12e2(5.12*10**2） 1、把一个绝对值大于等于1或小于10的实数记为a×10n的形式(比如1≤/a/&lt;10),这种记数法叫做科学记数法。例如19971400000000=1.99714×10^13。计算器或电脑表达10的的幂是一般是用E或e，也就是1.99714E13=19971400000000。2、用科学记数法表示数时，不改变数的符号，只是改变数的书写形式而已。可以方便的表示日常生活中遇到的一些极大或极小的数，如：光的速度大约是300,000,000米/秒；全世界人口数大约是：6,100,000,000.这样的数，读、写都很不方便，我们可以免去写这么多重复的0，将其表现为这样的形式：6,100,000,000=6.1×10^9，或：0.00001=1×10^-5，即绝对值小于1的数也可以用科学记数法表示为a乘10 的负n次方的形式。&lt; Python的复数 Python支持复数，复数的虚部用j或者J表达式 如果需要在程序对复数进行计算，可导入Python的cmath模块(c代表complex)，该模块下包含了各种支持复数运算的函数 Python编程-字符串入门 02字符串的基础用法 此处省略21天通过Python-李刚 字符串的拼接 将两个字符紧挨着写在一起，Python就会自动拼接 12 &quot;BuBuPython&quot;&quot;get-up&quot;# &#x27;BuBuPythonget-up&#x27; 使用加号 + 拼接两个字符串 12345st1 = &quot;我要学&quot;st2 = &quot;Python&quot;st1 + st2 ‘我要学Python’#这里的st1、st2是我定义的两个字符串 不同类型字符串拼接，拼接前需使用str()或repr()函数进行转化 12345pt1 = 25pt2 = 11.3# TypeError：st1+pt1st1 + str(pt1)# &#x27;我要学25&#x27; repr函数，input获取用户数据 repr()会以Python表达式的形式来表示值 12345678st2 = &quot;羞愧难当&quot;print (st2)# 羞愧难当st2 = repr(&quot;羞愧难当&quot;)print (st2) ‘羞愧难当’ #可以使用repr()函数来强制Python字符类型的表现形式 Python 获取用户输入 input()向用户生成一条提示，然后获取用户的输入内容 1234567 name = input(&quot;请输入你的名字：&quot;) print (name)&gt;请输入你的名字：帅B帅B#这次因为是执行两行代码，所以不能直接在IDE中打印，需要创建一个Python文件然后保存按F5来执行#执行后会直接跳出“请输入你的名字：”输入结果后程序获得结果并打印出来“帅B” Python2.x的raw_input()相当于Python3.x中的input() Python2.x的input()函数则比较怪异 长字符串与原始字符串 长字符串使用三个引号(单引号、双引号都可以)括起来 123456789101112 st8 = &#x27;&#x27;&#x27;你好 很高兴认识你 我叫田暴雷 叫我大雷就好 &#x27;&#x27;&#x27; print (st8)&gt;你好很高兴认识你我叫田暴雷叫我大雷就好#像这种字符串很长的字符，就可以用三组单引号来定义(赋值) Python会允许使用转义符(\\)对换行符转义，这样也可以定义字符串 #这里要实现“\\”需要多打两个或者三个才阔以￣□￣｜｜ 原始字符串 原始字符串以r开头，原始字符串不会把反斜杠\\当成特殊字符 12345 st = r&#x27;老司机带带我！\\n我要成大佬！&#x27; print (st)&gt;老司机带带我！\\n我要成大佬！#这里就成功的将\\\\当成一个字符串打印出来了 如果原始字符串中包含引号(一组引号的其中一个时)，程序同样需要对引号进行转义(否则Python同样无法对字符串的引号精确匹配) 123456789101112131415161718 st7 = r&#x27;教练我要学‘开车&#x27; print (st7) &gt; 教练我要学‘开车 st7 = &#x27;教练我要学&#x27;开车&#x27; &gt;SyntaxError: invalid syntax #这里运行报错，加上\\\\转义符后就可以将&#x27;号转为原始字符，如下 st7 = &#x27;教练我要学\\&#x27;开车&#x27; print (st7) &gt; 教练我要学&#x27;开车 st7 = &quot;教练我要学\\&#x27;开车&quot; print (st7) &gt;教练我要学&#x27;开车 #我试了试在一个数组中加一个独立的引号，运行直接报错了 字节串与字符串 字符串(str)由多个字符组成；字节串(bytes)由多个字节组成 bytes和str除了操作的数据单元不同之外，它们所支持的方法都基本相同，bytes也是不可变序列 A &lt;——-何为可变序列何为不可变序列—–&gt; B 字符串和字节串间的相互转化 将字符串转换成bytes对象有如下三种方式： 如果字符串内容都是ASCII字符，可以通过直接在字符串之前添加b前缀来构建字节串值 12345678st7 = b&#x27;你好&#x27;print (type(st7))# SyntaxError: bytes can only contain ASCII literal characters. st7 = b&#x27;abc&#x27;print (type(st7)) # &lt;class &#x27;bytes&#x27;&gt; 调用butes()函数(其实是bytes的构造方法)将字符串按指定的方式转化为字节串或转化为指定类型的字节串，默认使用UTF-8字符集 123st6 = &quot;我爱我家&quot;.encode()print (st6)# b&#x27;\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe6\\x88\\x91\\xe5\\xae\\xb6&#x27; 调用字符串本身的encode()方法将字符串按指定字符集转化成字节串，默认使用UTF-8字符集 1234st6 = bytes(&quot;我爱我家&quot;,&quot;UTF-8&quot;)print (st6)# b&#x27;\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe6\\x88\\x91\\xe5\\xae\\xb6&#x27;# 这种方式要加字符集否则Python会直接报错，不能正常运行 2.调用bytes对象的decode()方法将bytes对象解码成字符串 123st9 = b&#x27;\\xe6\\x88\\x91\\xe7\\x88\\xb1\\xe6\\x88\\x91\\xe5\\xae\\xb6&#x27;print (st9.decode(&quot;UTF-8&quot;))# 我爱我家 转义字符 03 在字符操作中\\表示转义，如果字符串本身包含反斜杠，则需要\\表示，其中\\就是转义字符 转义字符描述 \\(在行尾时) 续行符 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\a 响铃 \\b 退格(Backspace) \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 例： `st0 = &#39;J\\nK\\nL&#39;` J K L 字符串格式化 使用%加转换说明符的方式执行字符格式化，Python支持如下所示转换说明符 转义说明符说明 d,i 转换为带十进制的整数 o 转换为带符号的八进制整数 x,X 转换为带符号的十六进制整数 e,E 转换为科学计数法表示的浮点数(e小写、E大写) f,F 转换为十进制浮点数 g 智能选择f或e格式 G 智能选择F或E格式 c 转换为单字符(只接受整数或单字符字符串) r 使用repr()将变量或表达式转换为字符串 s 使用str()将变量或表达式转换为字符串 例： 123 st1 = &#x27;我爱%s&#x27; print (st1%&#x27;Python&#x27;)# 我爱Python #这里%s表示的是替代符要将替代**源对象**转换数组再替代进来到目标**位置上**(可能这种解释不是很对，个人理解) st2 = ‘我的名字是%s,我%d岁了’ print (st2 %(‘田大雷’,25)) 我的名字是田大雷,我25岁了 #这里因为有两个转换字符，它们所组成了一个元组，所以要用括号将这两个个准换符括起来 调用函数(方法)操作字符串 字符串本质就是由多个字符组成，字符的本质就是不可变序列，因此序列相关的方法： 基于索引的计算st3 = &#39;houdini.vfx&#39; print(st3[3]) print(st3[2:5]) print(st3[3:8:2]) d udi dn. #打印st3里的第三个字符 (开始) #打印st3字符串中第二个开始到第五个左右字符(包含开始，不包含结尾) (开始、结束) #打印st3字符串中第三个开始到第八个结束隔一个打印(间隔为2) (开始、结束、间隔) #常用于提取字符串中的指定字符 in运算st3 = &#39;houdini.vfx&#39; print (&#39;vfx&#39; in st3) print (&#39;rbd&#39; in st3) True False #in即 判断一个赋值串是否包含在某个字符串中 ，如果是返回True，否则返回False len()函数st3 = &#39;houdini.vfx&#39; print (len(st3)) 11 #用于计算字符串长度 min()\\max()函数st3 = &#39;houdini.vfx&#39; print (max(st3)) print (min(st3)) x . #而 max和min则用于分别求字符串中最大的字符串和最小的字符串 大小写相关的方法 title():将每个单词首字母改为大写 lower():将整个字符串改为小写 upper():将整个字符串改为大写 删除空白的方法 strip():删除字符串前后的空白 lstrip():删除字符串左边的空白 rstrip():删除字符串右边的空白 查找、替换相关的方法 startswith():判断字符串是否以指定字符开头 endswith():判断字符串是否以指定字符结尾 find():查找指定字符在字符串中的位置，如果找到返回位置信息，如果没有返回-1 index():查找指定字符在字符串中的位置，如果找到返回位置信息，如果没有则引发ValueError错误 replace():使用指定字符替换字符串中的目标字串 translate():使用指定的翻译映射对字符串执行替换 使用dir查询Python方法的使用方法dir(str) [‘_add_‘, ‘_class_‘, ‘_contains_‘, ‘_delattr_‘, ‘_dir_‘, ‘_doc_‘, ‘_eq_‘, ‘_format_‘, ‘_ge_‘, ‘_getattribute_‘, ‘_getitem_‘, ‘_getnewargs_‘, ‘_gt_‘, ‘_hash_‘, ‘_init_‘, ‘_init_subclass_‘, ‘_iter_‘, ‘le‘, ‘_len_‘, ‘_lt_‘, ‘_mod_‘, ‘_mul_‘, ‘_ne_‘, ‘_new_‘, ‘_reduce_‘, ‘_reduce_ex_‘, ‘_repr_‘, ‘_rmod_‘, ‘_rmul_‘, ‘_setattr_‘, ‘_sizeof_‘, ‘_str_‘, ‘_subclasshook_‘, ‘capitalize’, ‘casefold’, ‘center’, ‘count’, ‘encode’, ‘endswith’, ‘expandtabs’, ‘find’, ‘format’, ‘format_map’, ‘index’, ‘isalnum’, ‘isalpha’, ‘isascii’, ‘isdecimal’, ‘isdigit’, ‘isidentifier’, ‘islower’, ‘isnumeric’, ‘isprintable’, ‘isspace’, ‘istitle’, ‘isupper’, ‘join’, ‘ljust’, ‘lower’, ‘lstrip’, ‘maketrans’, ‘partition’, ‘replace’, ‘rfind’, ‘rindex’, ‘rjust’, ‘rpartition’, ‘rsplit’, ‘rstrip’, ‘split’, ‘splitlines’, ‘startswith’, ‘strip’, ‘swapcase’, ‘title’, ‘translate’, ‘upper’, ‘zfill’]#列数关于字符串的所有方法#前后带’__’的方法不能直接使用(后续课程补上)，其他可以直接使用，具体使用方法，使用**help(str.方法)**查阅 help(str.islower) Help on method_descriptor:islower(self, /) Return True if the string is a lowercase string, False otherwise. A string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.#查看字符串方法中islower的具体使用方法,以上就是对这个方法怎么使用的具体描述(需要一定的英文阅读能力⊙﹏⊙∥∣°) inta = float(input(&quot;请输入第一个数值：&quot;)) intb = float(input(&quot;请输入第二个数值：&quot;)) print(&quot;两个数的和为：&quot;+ str(inta+intb)) print(&quot;和的十六进制为:&quot; + hex(int(inta+intb))) print(&quot;两个数的差为：&quot; + str(inta-intb)) print(&quot;差的八进制为：&quot; + oct(int(inta-intb)) ) print(&quot;两个数的积为：&quot; + str(inta*intb)) print(&quot;积的二进制为：&quot; + bin(int(inta*intb))) www.runoob.com找到一个很好的python资料网站，记录起来，日后常翻！ 赋值运算符与扩展的赋值运算符 04 赋值运算符是 ‘ = ‘号 赋值运算符的作用是将等号右边的值赋予到等号左边的变量中 算术运算符 +、-、、/、//(整除)、%、*(乘方) div1 = 5/3 print(div1) div2 = 5//3 print(div2) 整除的结果总是只保留整数部分 mod1 = 23%7 print(mod1) 求余的结果总是与除数保持一致 print(4**5) print(1024**.25) print(1024**(1/5)) print(32**.5) ** 可以用来求乘方也可以用来求开方 如果要实现复杂的数学运算，可以导入math模块 扩展的赋值运算符 x += y,即对应与x = x+y x -= y,即对应与x = x-y x = y,即对应与x = xy x /= y,即对应与x = x/y x //= y,即对应与x = x//y x %= y,即对应与x = x%y x **= y,即对应与x = x**y 索引运算符 索引运算符就是 [ ] 方括号 方括号中可使用单个索引，用于访问单个元素 方括号中也可以使用索引范围，使用索引范围时，还可以指定步长 str2 = &quot;HoudiniVFX&quot; print(str2[-2]) print(str2[1:5:2]) 索引运算符对所有的序列**(字符串、字节串、列表、元组)**都起作用 比较运算符和逻辑运算符比较运算符&gt; 、&gt;= : 大于、大于或等于 \\&lt;、\\&lt;=:小于、小于或等于 ==：等于 ！=：不等于 is(is not):判断两个变量引用的对象是否相同(不相同)，如果相同(不相同)返回True，否则返回False 逻辑运算符and:与，任一操作中为False，结果返回Falseor:或，任一操作中为True，结果返回Truenot:非，只需要一个操作数，如果操作数为True，则返回False；如果操作数为False，则返回True 三目运算符 Python使用if表达式代替三目运算符 True_statements if expression else False_statements if支持嵌套 name = str(input(&quot;请输入你的名字：&quot;)) age = int(input(&quot;请输入你的熟练度：&quot;)) print(name[-2:] + &quot; 先生/女士&quot; + &quot;您好！&quot;) if(age &gt; 4500) else print(name[-2:] + &quot; 小朋友&quot; + &quot;你好呀！&quot;) in运算符 用于判断元素是否在一个序列(字符串、字节串、序列、元组)中 str3 = &quot;吸油糖&quot; print(&quot;吸&quot; in str3) print(&quot;广州&quot; in str3) 通过索引访问元素 05列表和元组都可以通过索引来访问元素： Python文件书写标准开头模板 # -*- coding: utf-8 -*- # @Time : 2019/7/25 12:53 # @Author : yaogang_li # @File : 2.2列表和元组.py 一种是正向访问(从左到右)，索引从0开始：第一个元素索引为0，第二个元素索引为1，…..以此类推； 一种是反相访问(从右到左)，索引从-1开始：倒数第一个元素索引为-1，倒数第二个元素索引为-2,….以此类推; my_tuple = tuple(range(3,10)) print(my_tuple) len()函数可以获取对象元素的长度(元素数量) print(len(my_tuple)) print(str(“打印my_tuple第二个元素为：”) + str(my_tuple[2])) print(str(“打印my_tuple倒数第二个元素为：”) + str(my_tuple[-2])) 当你使用索引访问元素时，你的索引必须在 -len ~ len-1之间，否则程序就会报错(IndexError: tuple index out of range)##print(str(“打印my_tuple倒数第二个元素为：”) + str(my_tuple[20])) 子序列 列表和元组也可以使用索引获取元素中间字符，这种方法被称为slice(分片和切片)slice的完整格式 [start: end :step] 开始：结束：步幅 my_list1 = str(&quot;降世魔童&quot;) print (my_list1[0:3:2]) my_tuple1 = (1,3,5,8,4,2,&quot;Python&quot;,&quot;Houdini&quot;,&quot;Maya&quot;) print(my_tuple1[0: -1 :2]) 获取子序列(元素的中间字符/序列的中间元素) 元组和列表的加减 my_list2 = [&quot;动画电影&quot;] #列表 my_tuple2 = (25,5,10,82,&quot;神兵小将&quot;) #元组 print (list(my_list1) + my_list2) print (tuple(my_tuple1) + my_tuple2) print (my_list2+ list(my_tuple2)) 列表需要使用 [ ] 中括号括起来，元组则是 ( ) 小括号；数组则直接返回字符串不带符号(可强制返回引号 吗？) print(my_list1) print(my_list2) print(my_tuple2) 序列相关函数与封包解包len()、max()、min()函数 len()、max()、min()函数可分别获取元组或者列表的长度、最大值、最小值 mystr1 = &quot;我是一个热爱生活的艺术家！&quot; mylist1 = [&quot;Python&quot;,&quot;Houdini&quot;,&quot;Maya&quot;,&quot;Nuke&quot;,&quot;帅刚&quot;] mytuple1 = (&quot;亦建&quot;,&quot;淮宝&quot;,&quot;思婷&quot;,&quot;啊凡&quot;,&quot;啊航&quot;,&quot;雅思&quot;) print(len(mystr1),max(mystr1),min(mystr1)) print(len(mylist1),max(mylist1),min(mylist1)) print(len(mytuple1),max(mytuple1),min(mytuple1)) 字符串比较大小时，将会依次按字符串中每个字符对应的编码来比较大小 字符串比较大小时，先比较第一个字符的大小，再比较第二个字符…. 序列封包 在Python里把多个值赋予给一个变量时，Python会自动将多个值封装成元组。这种功能被称为序列封包 data1 = 3,6,&quot;Houdini&quot;,&quot;Nuke&quot; print(len(data1)) print(type(data1).__name__) 序列解包 序列(元组或列表等)可以直接赋予多个变量，此时序列的元素会被依次赋予给每个变量**(要求序列的元素个数和变量个数相等)**，这种功能被称为序列解包 mylist1 = [&quot;Python&quot;,&quot;Houdini&quot;,&quot;Maya&quot;,&quot;Nuke&quot;,&quot;帅刚&quot;] mytuple1 = (&quot;亦建&quot;,&quot;淮宝&quot;,&quot;思婷&quot;,&quot;啊凡&quot;,&quot;啊航&quot;,&quot;雅思&quot;) str1 = &quot;Python&quot;,&quot;Houdini&quot;,&quot;VFX&quot; a,b,c = str1 d,e,f = mylist1[-3:] g,h,i = mytuple1[0:3] print(a,b,c,d,e,f,g,h,i) .有时候需要解包的对象元素大于要分配的变量个数时，可以使用slice的方式获取其中一部分来解包赋值. 封包适用于元组、列表、字符串等序列,包括(range) j,k,l,m = range(520,524) print(j,k,l,m) 当只需要解包其中一个元素给特定变量其他变量随意分配时，可以在随意分配的变量前加一个号，这样就会先按照顺序自动解包赋予上值，剩下的就会以列表的形式赋予给由号的变量 mylist1 = [&quot;Python&quot;,&quot;Houdini&quot;,&quot;Maya&quot;,&quot;Nuke&quot;,&quot;帅刚&quot;] mytuple1 = (&quot;亦建&quot;,&quot;淮宝&quot;,&quot;思婷&quot;,&quot;啊凡&quot;,&quot;啊航&quot;,&quot;雅思&quot;) n,*o,p = mystr1 q,r,*s = mytuple1 print(n,o,p,q,r,s) 我 [‘是’, ‘一’, ‘个’, ‘热’, ‘爱’, ‘生’, ‘活’, ‘的’, ‘艺’, ‘术’, ‘家’] ！ 亦建 淮宝 [‘思婷’, ‘啊凡’, ‘啊航’, ‘雅思’] 多个变量同时赋值 Python的赋值运算符支持同时将多个值赋予给多个变量，这是因为Python同时运用了序列的封包和解包t,u,v = &quot;Python&quot;,&quot;Houdini&quot;,&quot;VFX&quot; print(t,u,v) 这里就是先将等号右边的三个字符串打包成元组，再依次解包赋值到对应的变量上 列表的添加、删除、替换 06添加 append() 方法会把传入的参数追加到列表的最后 append()方法追加另一个列表(序列)时，列表被 当成一个元素 extend() 方法用于追加另一个列表(序列)，他会将列表(序列)中的元素 拆分后追加 进来 insert() 方法将元素 插入列表指定位置 #列表元素的添加 list1 = [&quot;吸油糖&quot;,&quot;Houdini&quot;,&quot;VFX&quot;] list2 = [1,3,5,7,9] list3 = [3] list4 = [4] list5 = [5] list3.append(list1) #加入一个元素 print(list3) list4.extend(list1) #拆分元素再加入 print(list4) list5.insert(0,list1) #插入指定位置 print(list5) 删除 #列表元素的删除，使用del函数实现元素的删除 list_a = [&quot;吸油糖&quot;,&quot;Houdini&quot;,&quot;VFX&quot;] list_b = [1,3,5,7,9] del list_a[0] #删除指定元素 print(list_a) del list_b[1:4] print(list_b) #删除指定范围内的元素 list_a.extend(list_b) del list_a[0:3:2] print(list_a) #删除范围内指定步幅的元素 替换 对列表的元素赋值即可修改列表中的元素 还可以通过slice语法对列表的其中一部分赋值，对列表的其中一部分赋值时，并不要求新值的元素个数与原元素个数相等；这种行为即可为列表增加元素，也可为列表删除元素 对列表的slice语法赋值时，不能使用单个值；如果使用字符串赋值，Python会自动把字符串当成序列处理 #列表元素的替换(增加、删除) list_1 = [&quot;魔丸&quot;,&quot;魔童&quot;,&quot;哪吒&quot;,&quot;命运&quot;,&quot;友情&quot;,&quot;亲情&quot;] list_2 = [&quot;故事&quot;,&quot;节奏&quot;,&quot;画面&quot;,&quot;超赞&quot;] list_3 = [] list_1[0:3] = list_3 print(list_1) #这里因为list_3为一个空对象，所以将0-3四个元素替换为空，就等于删除了list_1中0-3的元素 list_1[0:1] = list_2 print(list_1) #这里list_2元素个数大于0-1两个，所以相当与增加了list_1的元素 #列表元素的替换其实就是对列表元素中的指定元素重新赋值 列表的常用手法列表的几个常用方法 使用dir()list可查看列表支持的方法，使用help(方法)来查看方法的具体使用方式 #列表常用的一些方法演示 #count() 求列表中某个元素出现的次数 print(list_2.count(&quot;画面&quot;)) #index() 元素再列表中的位置 print(list_2.index(&quot;超赞&quot;)) #reverse() 反转列表/序列的排列顺序 list_2.reverse() print (list_2) #sort() 排序，默认是根据字符编码对列表/序列中的元素进行排序 list_2.sort() print(list_2) #__len__ 获取列表/序列的元素个数/长度 print(list_2.__len__()) 创建字典 07什么是字典 字典就是用于保存具有映射关系的数据，字典相当于保存两组数据，其中一组是关键数据，成为key；另一组数据可以通过key来访问，被称为value 特性： 字典中每一个key对应一个value,每一个key都不能相同，但是value可以多个相等创建字典 花括号法：花括号应包含多组key-value对，key-value之间用英文的冒号隔开；多组key-value对之间使用英文逗号隔开123 #字典中key和value一一对应，key都是独一无二的不可以相同，value可以多个相同scores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;print(scores) dict构造器：可以传入多个列表或元组参数作为key-value对；也可以为dict指定关键字参数创建字典，此时字典的key不允许使用表达式123 #使用dict创建字典时，列表/序列中的每个元素必须包含两个子元素如下，如若子元素个数不为2，则字典创建失败，返回&#x27;ValueError: dictionary update sequence element #3 has length 3; 2 is required&#x27;dicta = dict([(&#x27;小学&#x27;,7),(&#x27;初中&#x27;,13),(&#x27;高中&#x27;,16),(&#x27;大学&#x27;,19)])print(dicta) 123#使用关键字参数创建字典(dict)时，不能使用表达式dictb = dict(小学=7,初中=13,高中=16,大学=19)print(dictb) 字典的key是不可变的，因此列表不能作为dict的key 操作字典key-value对 使用方括号和key来访问key对应的value值123#字典中通过key访问valuedictb = dict(小学=7,初中=13,高中=16,大学=19)print(dictb[&#x27;高中&#x27;]) 当对不存在的key赋value值时，相当于给字典添加字典元素1234#字典元素的添加dictb = dict(小学=7,初中=13,高中=16,大学=19)dictb[&#x27;社会实践&#x27;] = &#x27;forever&#x27;print(dictb) 当对已存在的key赋value值时，相当于替换字典中对应key的value值1234 #字典元素替换dictb = dict(小学=7,初中=13,高中=16,大学=19)dictb[&#x27;高中&#x27;] = &#x27;forever&#x27;print(dictb) 删除key-value对1234 #字典元素的删除dictb = dict(小学=7,初中=13,高中=16,大学=19)del dictb[&#x27;高中&#x27;]print(dictb) 将指定的key赋值为None时不能删除key-value对 12345678 #字典元素的删除dictb = dict(小学=7,初中=13,高中=16,大学=19)del dictb[&#x27;高中&#x27;]dictb[&#x27;大学&#x27;] = Noneprint(dictb)del dictb[&#x27;大学&#x27;]print(dictb)#我这里赋值为None后依然可以被删除，有点疑惑这是为什么，大佬可以评论告诉我，谢谢！ 使用in、not in判断dict是否包含指定的key 1234#使用in 、not in判断元素是否再字典内dictb = dict(小学=7,初中=13,高中=16,大学=19)print(&#x27;小学&#x27; in dictb) #返回True 说明&#x27;小学&#x27;在dictb中print(&#x27;初中&#x27; not in dictb) ##返回False 说明&#x27;小学&#x27;在dictb中 理解dict和list的关系 字典相当于索引，是任意不可变类型的列表，而列表相当于key只能是整数的字典；如果程序中要使用字典的key都是整数类型，则可以考虑是不是要换成列表 列表的索引总是从0开始，也不需要连续。因此列表不允许对不存在的索引赋值；但字典则允许直接对不存在的key赋值，这样就会直接给字典新增了一对key-value值 # 总结： 字典(dict)和列表(list)都是可变的，都可以对内部元素进行增加、删除、修改的操作 但是因为字典的key是不可变的，所以列表(list)不能直接赋值于key 字典用法的进阶字典的常用方法 dir(dict) 查看字典所支持的方法 clear() 用于清空字典的所有key-value对1234 #clear()清空字典内所有key-value,被清空的字典就是一个空字典返回&#x27;&#123;&#125;&#x27;scores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;scores.clear()print(scores) get() 方法其实就是根据key来获取value123 #get()根据key来获取value值scores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;print(scores.get(&#x27;数学&#x27;)) update()方法可使一个字典所包含的key-value对来更新另一个已有的字典.123456789101112131415 #使用update()方法，用一个新的字典去更新另一个已有的字典scores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;scores_a = &#123;&#x27;语文&#x27;:90,&#x27;数学&#x27;:98,&#x27;生物&#x27;:76&#125;scores_b = [(&#x27;历史&#x27;,98),(&#x27;自然&#x27;,75),(&#x27;Python&#x27;,100)]scores_c = dict(彭同学=88,雷同学=79,李同学=90) #注意使用关键字定义字典时，括号内不允许有表达式(key不需要引号)scores.update(scores_a)print(scores)#更新目标.update(使用对象)scores_a.update(scores_b)print(scores_a)#若字典使用序列作为参数，此时序列的每个元素必须包含两个子元素，第一个是key，第二个是valuescores_temp = dict(scores_b) #先将列表转为字典scores_temp.update(scores_c) #再使用scores_c,来更新这个转化好的字典print(scores_temp)#注意使用关键字定义字典时，括号内不允许有表达式(key不需要引号) iteme()、keys()、value()分别用于获取字典中所有的key-value、所有的key、所有的value12345678910#使用items()、keys()、values()分别遍历字典中的所有元素(每个元素包含一个key，一个value)、遍历字典中的所有key(只遍历key)、遍历所有value(只遍历value)scores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;for key in scores.keys(): print(key) for value in scores.values(): print(value) for item in scores.items(): #liems这里面使用到了序列的解包 print(item) pop() 方法用于获取、并删除指定key对应的value12345#使用pop()方法获取并删除key对应的value(删除并返回key对应的value值)scores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;return1 = scores.pop(&#x27;地理&#x27;)print(scores)print(return1) popitem()方法用于随机地弹出字典中一个key-value对 setdefault()方法也用与根据key来获取对应value的值，并为不存在的key设置默认值(创建字典的地三种方法)123456#使用setdefault()方法获取对应key的value值,如果key不存在，则添加一个key到字典中并设置value为Nonescores = &#123;&#x27;语文&#x27;:89,&#x27;数学&#x27;:78,&#x27;英语&#x27;:95,&#x27;地理&#x27;:78&#125;a = scores.setdefault(&#x27;数学&#x27;)print(a)scores.setdefault(&#x27;生物&#x27;)print(scores) fromkeys() 方法可将序列转化为字典,可以给转化的字典设置一个固定的value值123#使用formkeys()转化序列为字典d = dict.fromkeys([&#x27;RNG&#x27;,&#x27;IG&#x27;,&#x27;BLG&#x27;,&#x27;LNG&#x27;],35) #dict.fromkeys(序列，value默认值) = newscoresprint(d) 使用字典对字符串格式化 在字符串模板中按key指定变量，然后通过字典为字符串模板中的key设置值12345 #使用字典格式化字符串str1 =&quot;今年是%4.0f年&quot;&quot;我在学习%s&quot;print(str1%(2019,&#x27;Python&#x27;)) #普通的格式化字符串str2 = &quot;今年是%(nian)4.0f年&quot;&quot;我在学习%(name)s&quot; #字典格式化字符串print(str2 % &#123;&#x27;nian&#x27;:2019,&#x27;name&#x27;:&#x27;Python&#x27;&#125;) 总结: 两种字符格式化原理其时是一样的，不同的时第一种是根据字符的先后位置来填充字符串；而字典格式化字符串则是根据设置好的key来指定对应的value","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"}],"author":"luomit"},{"title":"PyQt5创建基础UI","slug":"筆記/python/PyQt创建UI","date":"2020-02-20T04:06:44.000Z","updated":"2021-05-12T09:41:27.245Z","comments":true,"path":"2020/02/20/筆記/python/PyQt创建UI/","link":"","permalink":"https://luomit.github.io/2020/02/20/%E7%AD%86%E8%A8%98/python/PyQt%E5%88%9B%E5%BB%BAUI/","excerpt":"","text":"Python3学习网站收藏Python官网下载对应系统的安装文件进行安装；Python文档有各个版本的Python多种语言的技术文档说明；Runoob编程中文文档PyQt5-Python学习笔记文档 PyQt5安装windows10安装PyQt5-toolpyqt2-tool下载使用CMD运行如下代码 1pip install pyqt5-tools 这里建议先安装pyqt5-tool再安装pyqt5，避免安装pyqt5时报错，若是仍然有报错可参考 windows10安装PyQt5pyqt5下载使用CMD运行如下代码 1pip install pyqt5 如是提示pip版本过低执行 1python -m pip install --upgrade pip 升级pip版本后在执行上一条命令安装PyQt5 PyCharm配置PyQt5PyCharm安装PyCharm官网下载学习版设置 PyCharm配置Python文件代码模板 1234567##!/usr/bin/python# -*- coding: utf-8 _*_# @Time :$&#123;DATE&#125; $&#123;TIME&#125;# @Author :luomit# @Email :1107199736@qq.com# @File :$&#123;NAME&#125;.py# @Project :$&#123;PROJECT_NAME&#125; PyQt5其他配置参考 PyQt5创建UI基础窗口 置顶12345678910111213141516171819202122232425import sysfrom PyQt5.QtWidgets import *from PyQt5.QtGui import *from PyQt5.QtCore import *class MainWindows(QWidget): def __init__(self): super(MainWindows, self).__init__() self.setWindowTitle(&quot;主窗口&quot;) # 设置窗口标题 self.resize(800, 600) # 重设尺寸 self.move(0, 0) # 移动窗口 # self.setGeometry(0,0,800,600) #相当于move + resize self.setWindowIcon(QIcon(&#x27;icon path&#x27;)) # 设置窗口的图标 self.setWindowFlag(Qt.WindowStaysOnTopHint, True) # 设置窗口标旗，置顶标旗 # self.setStyleSheet(&#x27;background(100,200,200)&#x27;) #通过样式的方法把窗口背景的颜色设置为(100，200，200)if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) a = MainWindows() a.show() # show是窗口的显示方法，hide时窗口的隐藏方法，close窗口的关闭方法 app.exec_() 123456789101112131415161718192021import sys#引入必要的模块，窗口的基本控件位于QtWidgets模块中from PyQt5.QtWidgets import QApplication, QWidgetif __name__ == &#x27;__main__&#x27;: #每一个PyQt5程序必须创建一个应用程序对象。argv参数是一个列表，从命令行输入参数 app = QApplication(sys.argv) #QWidget部件时PyQt5所有用户界面的基类，它为构建窗口界面提供默认构造，默认构造没有父对象 w = QWidget() #重设窗口的大小 w.resize(300,250) #设置窗口的标头 w.setWindowTitle(&quot;luomit windows&quot;) #设置窗口的位置 w.move(300,300) #show显示窗口 w.show() #使用exit()方法确保应用程序干净的退出 #exec_有下划线是因为这里执行的时一个Python的关键词，因此exec_替代 sys.exit(app.exec_()) 常用控件QPushButton Label 123456789101112131415161718192021222324252627282930313233import sysfrom PyQt5.QtWidgets import*from PyQt5.QtGui import *from PyQt5.QtCore import *class Buttom(QPushButton): def __init__(self): super(Buttom, self).__init__() self.setText(&quot;按钮&quot;) #self.setIcon() self.clicked.connect(self.print123) self.clicked.connect(lambda:print(456)) print(self.text()) def print123(self): print(123)class Label(QLabel): def __init__(self): super().__init__() self.setText(&#x27;大标签&#x27;) self.setAlignment(Qt.AlignVCenter | Qt.AlignHCenter) # |按钮或运算 #self.setPixmap(QPixmap(&#x27;map path&#x27;)) #像素图 #获取参数的方法 print(self.text()) print(self.alignment())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) a = Label() a.show() app.exec_() 窗口提示12345678910111213141516171819202122232425262728import sysfrom PyQt5.QtWidgets import (QWidget,QToolTip,QPushButton,QApplication)from PyQt5.QtGui import QFontclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): QToolTip.setFont(QFont(&quot;sansSerif&quot;,10)) self.setToolTip(&quot;这是一个UI提示测试脚本&quot;) btn = QPushButton(&quot;Button&quot;,self) btn.setToolTip(&quot;这是一个按钮提示&quot;) btn.resize(btn.sizeHint()) btn.move(50,50) self.setGeometry(300,300,300,200) self.setWindowTitle(&quot;Tooltips&quot;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 消息提示框123456789101112131415161718192021222324import sysfrom PyQt5.QtWidgets import QWidget, QPushButton, QApplicationfrom PyQt5.QtCore import QCoreApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): qbtn = QPushButton(&quot;Quit&quot;, self) qbtn.clicked.connect(QCoreApplication.instance().quit) qbtn.resize(qbtn.sizeHint()) qbtn.move(50, 50) self.setGeometry(300, 300, 300, 200) self.setWindowTitle(&quot;Quit button&quot;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 消息提示框1234567891011121314151617181920212223242526272829import sysfrom PyQt5.QtWidgets import QWidget, QMessageBox, QApplication#QMessageBoxclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 250, 150) self.setWindowTitle(&#x27;Message box&#x27;) self.show() # 定义关闭触发方法 def closeEvent(self, event): reply = QMessageBox.question(self, &#x27;Message&#x27;,&quot;Are you sure to quit?&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.No) if reply == QMessageBox.Yes: event.accept() else: event.ignore()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 显示窗口到屏幕中心1234567891011121314151617181920212223242526272829303132import sysfrom PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250,150) self.center() self.setWindowTitle(&quot;Center&quot;) self.show() #控制窗口显示在屏幕中心的方法 def center(self): #获得窗口 qr = self.frameGeometry() #获取屏幕中心点坐标 cp = QDesktopWidget().availableGeometry().center() #显示到屏幕中心 qr.moveCenter(cp) self.move(qr.topLeft())if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) PyQt的布局程序指定每个控件的位置和大小(以像素为单位px) 绝对布局绝对布局有以下限制: 调整窗口，控件元素的大小和位置不会改变 会因使用的场景影响其显示效果 如改变内部元素，应用程序的布局就会改变 123456789101112131415161718192021222324252627import sysfrom PyQt5.QtWidgets import QWidget, QLabel, QApplicationclass Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): laba = QLabel(&#x27;好想出去玩啊&#x27;,self) laba.move(15,10) labb = QLabel(&#x27;肺炎啥时候走&#x27;,self) labb.move(35,40) labc = QLabel(&#x27;我看不见病毒&#x27;,self) labc.move(55,70) self.setGeometry(300,300,250,150) self.setWindowTitle(&#x27;绝对布局案例&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 相对布局-框布局BoxLayout123456789101112131415161718192021222324252627282930313233343536import sysfrom PyQt5.QtWidgets import (QWidget,QPushButton,QHBoxLayout,QVBoxLayout,QApplication)#导入PyQt的纵向布局方法和横向布局方法class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): okButton = QPushButton(&#x27;OK&#x27;) cancelButton = QPushButton(&#x27;Cancel&#x27;) #设置纵向布局方式然后添加一个纵向拉伸因子并创建两个Button hbox = QHBoxLayout() hbox.addStretch(1) hbox.addWidget(okButton) hbox.addWidget(cancelButton) #设置横向布局，并设置横向拉伸因子来将按钮推向右侧 vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) #最后将设置到全局窗口中 self.setLayout(vbox) self.setGeometry(300,300,250,150) self.setWindowTitle(&#x27;绝对布局案例&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 相对布局-表格布局QGridLayout1234567891011121314151617181920212223242526272829303132333435363738import sysfrom PyQt5.QtWidgets import (QWidget,QPushButton,QGridLayout,QApplication)class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): grid = QGridLayout() self.setLayout(grid) #实例化QGridLayout表格布局样式并设置到应用程序布局 name = [&#x27;Cls&#x27;,&#x27;Bck&#x27;,&#x27;&#x27;,&#x27;Close&#x27;, &#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;/&#x27;, &#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;*&#x27;, &#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;-&#x27;, &#x27;0&#x27;,&#x27;.&#x27;,&#x27;=&#x27;,&#x27;+&#x27;] #创建按钮到一个字符串数组中 positions = [(i,j)for i in range(5)for j in range(4)] for position,name in zip(positions, name): if name == &#x27;&#x27;: continue button = QPushButton(name) grid.addWidget(button,*position) #使用for in 将数组字符串解包依次对应到各自位置上 self.move(300,150) self.setWindowTitle(&#x27;Grid布局案例&#x27;) self.show()if __name__ == &#x27;__main__&#x27;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 相对布局-跨行表格布局import sys from PyQt5.QtWidgets import (QWidget,QLabel,QLineEdit,QTextEdit,QGridLayout,QApplication) class Example(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): title = QLabel(&#39;Title&#39;) author = QLabel(&#39;Author&#39;) review = QLabel(&#39;Review&#39;) titleEdit = QLineEdit() authorEdit = QLineEdit() reviewEdit = QLineEdit() grid = QGridLayout() grid.setSpacing(10) grid.addWidget(title,1,0) grid.addWidget(titleEdit,1,1) grid.addWidget(author,2,0) grid.addWidget(authorEdit,2,1) grid.addWidget(review,3,0) grid.addWidget(reviewEdit,3,1,5,1) self.setLayout(grid) self.setGeometry(300,300,350,300) self.setWindowTitle(&#39;跨行表格布局案例&#39;) self.show() if __name__ == &#39;__main__&#39;: app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_())","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://luomit.github.io/tags/PyQt5/"}],"author":"luomit"},{"title":"Python基础(02)","slug":"筆記/python/Python基础(02)","date":"2020-02-20T04:06:44.000Z","updated":"2021-05-12T09:41:25.948Z","comments":true,"path":"2020/02/20/筆記/python/Python基础(02)/","link":"","permalink":"https://luomit.github.io/2020/02/20/%E7%AD%86%E8%A8%98/python/Python%E5%9F%BA%E7%A1%80(02)/","excerpt":"","text":"分支和循环if else 的三种写法1234567891011source = int(input(&quot;input number: &quot;))if 100 &gt;= source &gt;= 90: print (&quot;A&quot;)if 90 &gt; source &gt;= 75: print (&quot;B&quot;)if 75 &gt; source &gt;= 60: print (&quot;C&quot;)if 60 &gt; source &gt;= 0: print (&quot;D&quot;)else: print(&quot;Error!&quot;) 1234567891011121314source = int(input(&quot;input number: &quot;))if 100 &gt;= source &gt;= 90: print (&quot;A&quot;)else: if 90 &gt; source &gt;= 75: print (&quot;B&quot;) else: if 75 &gt; source &gt;= 60: print (&quot;C&quot;) else: if 60 &gt; source &gt;= 0: print (&quot;D&quot;) else: print (&quot;Error!&quot;) 1234567891011source = int(input(&quot;input number: &quot;))if 100 &gt;= source &gt;= 90: print (&quot;A&quot;)elif 90 &gt; source &gt;= 75: print (&quot;B&quot;)elif 75 &gt; source &gt;= 60: print (&quot;C&quot;)elif 60 &gt; source &gt;= 0: print (&quot;D&quot;)else: print (&quot;Error!&quot;) python对缩进的要求很严格，这是的python的代码更加的简洁和已读。 断言(assert)assert称之为“断言”，assert后面的条件为假时，程序自动崩溃并抛出assertionError的异常 1assert 3 &gt; 4 AssertionError 一般来说我们可以用Ta在程序中置入检查点，当需要确保程序中的某个条件一定为真才能让程序正常工作的话，asser关键字就非常有用了。 while 循环12while 条件: 循环体 for 循环12for 目标 in 表达式: 循环列表 1234name = &quot;python&quot;for i in name: print (i, end=&#x27; &#x27;)# 循环python每个字符，每次打印循环的字符和一个空格 123name = [&quot;python&quot;,&quot;bilibili&quot;]for i in name: print(i, len(i), type(i)) range 范围12for i in range(9): print (i) 12for i in range(10,25): print (i) break 和 continuebreak 终止当前循环continue 终止本轮循环，开始下一轮循环 1234for i in range(10,25): print (i) continue #终止本轮循环，开始新循环 print (&quot;i = &quot;,i) break 通常使用在代码的末尾，或者满足特定条件时，用来结束程序的运行；continue 通常用来检查代码判断，执行continue上面的循环，忽略continue下面的操作。 数组(列表)list将各种数据打包，放到一个组(列表)中； 123mix = [1, &quot;闪电&quot;, 2.55, &#123;1,0,0&#125;]print (mix[1])# 创建一个列表，并将第“1”个元素打印 添加元素的三种方法xx.append(元素) append加入新的元素xx.extend([“a”,”b”,”c”]) 将两个已有的数组组装在一起xx.insert(5,”大保健”) 将新的元素插入到列表对象的第5个位置上 123456mix = [1, &quot;闪电&quot;, 2.55, &#123;1,0,0&#125;]print (mix)mix.append(&quot;C##&quot;) # 加入元素(数据)到已有数组(列表)中print(mix)mix.extend([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])print(mix) [1, ‘闪电’, 2.55, {0, 1}][1, ‘闪电’, 2.55, {0, 1}, ‘C##’][1, ‘闪电’, 2.55, {0, 1}, ‘C##’, ‘a’, ‘b’, ‘c’][1, ‘闪电’, 2.55, {0, 1}, ‘C##’, ‘大保健’, ‘a’, ‘b’, ‘c’] 获取数组元素xx[number] 获取第几个在中括号内填写位置序号 删除数组元素xx.remove[&#39;元素&#39;] 使用remove删除数组元素，不需要元素在数组中的位置，只需要知道数组中的具体元素；del xx[number] 使用del删除数组元素，不需要知道具体元素，只需要知道元素在数组中的位置。xx.pop() pop方法剔除数组最后一个元素并返回该元素，如果填上序号，则从剔除对应序号上的元素 列表分片(分离列表或元素)Slicexx[1:3] 指定元素序号范围提取列表元素，不影响原列表xx[:3] 分离从开始到第三个元素xx[:] 复制拷贝一个与原数组一样的新数组tips: 这里的拷贝，就是复制一份，新复制的和原来的就没有了关联； 如果是将列表赋值到一个新列表(镜像复制)，则当该列表发生改变，新列表也会发生改变 1234mix = [1, &quot;闪电&quot;, 2.55, &#123;1,0,0&#125;] a = mix[:] a.reverse() b = mix 操作符in 或not inin 或者not in都可以用来判断元素是否在数组列表中，如果成立返回True countxx.count(元素) 元素在列表中的数量(长度) indexxx.index(元素) 返回元素在列表中的位置 reversexx.reverse() 翻转元素在列表中的排序 sortxx.sort(reverse=False) 让列表内所有元素按照从小到大进行排序xx.sort(reverse=True) 从大到小 123str = [199,3,145,54]str.sort(); # 什么都不写默认为升序，从小到大，结束要加分号print(str) sort方法使用对象的元素必须是同种类型 dir(list)dir(list) 列出python中关于list(数组或者列表)的所有方法 元组tuple元组最大的特点就是不可改变数组用中括号表示，元组使用小括号 12a = [a,b,c,d,e] #这是一个数组b = (a,b,c,d,e) #这是一个元组 1234c = 1,print (type(c))d = (1,2,3,4)print (type(d)) 使用slice改变元组1234e = (0,1,2,3,4,5)print (e)e = e[0:2] +(&quot;牛逼&quot;,) +e[2:]print (e) 元组的操作符基本上和列表相同 字符串 操作符 说明 capitaliz() 将整个字符串第一个字符改为大写 casefold() 将整个字符串所有字符改为小写 center(width) 将字符串居中，并使用空格填充至长度width的新字符串 count(sub[,start,[end]]) 返回sub在字符串里出现的次数，start和end参数表示范围，可选 encode(encoding=’utf-8’,error=’start’) 以encoding指定的编码格式对字符串进行编码 expandtabs([tabsize=8]) 把字符串中的tab符号(\\t)转换为空格，如不指定参数，默认空格数是tabsize=8 find(sub[,start[,end]]) 检测sub是否包含在字符串中，如果有则返回索引，否则返回-1，start和end参数表示范围，可选 index(sub[,start[,end]]) 跟find方法一样，不过如果sub不在string中会产生一个异常 鱼C论坛Python速查 字符串格式化xx.format() 位置参数格式化,关键字参数格式化 123temp = &quot;&#123;0&#125; love &#123;1&#125; &#123;2&#125;&quot;.format(&quot;I&quot;,&quot;Houdini&quot;,&quot;vfx&quot;)print(temp)# 位置参数格式化 123temp = &quot;&#123;a&#125; love &#123;b&#125; &#123;c&#125;&quot;.format(a=&quot;I&quot;,b=&quot;Houdini&quot;,c=&quot;vfx&quot;)print(temp)# 关键字参数格式化 两种格式化方法混用时，位置参数要在关键字前 字符串操作符 操作符 说明 %c 格式化字符及其ASCII %s 格式化字符串 %d 格式化整数 %o 格式化无符号八进制数 %x 格式化无符号十六进制数 %X 格式化无符号十六进制数(大写) %f 格式化定点数，可指定小数点后的精度 %e 用科学计数法格式化定点数 %E 作用同%e %g 根据值的大小决定使用%f或%e %G 作用同%g 序列 列表、元组和字符串的共同点 都可以通过索引得到每一个元素 默认索引值总是从0开始 可以通过分片的方式得到指定范围内的元素的集合 有着许多共同的操作符(重复操作符、拼接操作符、成员关系操作符) list() 转换为列表tuple() 转换为元组str() 转换为字符串len() 返回长度max() 返回最大值(对象元素必须是同一类型)min() 返回最小值(对象元素必须是同一类型)sum() 返回总和(对象元素必须是数值类型)reversed() 翻转enumerate() 枚举，返回结果是由元素和元素序号组成的元组对象；使用list转化为数组如下代码所示 12numbers = [1,15,12,32,44,24,35,51,61]print (list(enumerate(numbers) zip 返回由各个序列元素组成的元组 123a = [1,2,3,4,5]b = [7,8,9,5,4]print(list(zip(a,b))) 函数函数定义自定义定义函数的基本框架 12345# def 函数名():# 程序代码块def MyFunction(): print(&quot;人生苦短，我爱python&quot;) print(&quot;世界之大，我要去摩旅&quot;) 调用函数MyFunction() 123def MyMult(a,b): return(a*b)MyMult(5,10) return 用来返回代码块运行结果，与print不同return返回结果并不会打印出来; 参数形参parameter和实参argument 123456def MyFunction(name): &#x27;打印输入元素&#x27; # 使用‘’“”加说明为函数添加函数说明，使用help(函数)查看 #函数定义过程中的name叫做行参，它只是一个形式，用来表示占据一个参数的位置 print (name)MyFunction(&quot;呵呵&quot;) # 这里的“呵呵”就是实参，它代表了具体参数 关键字参数 12345def MyFunction(name,say): # 在定义函数时，有时候会有多个参数的输入，可以在形参定义时命好各个参数的名字，然后传入实参时按照形参名获取参数 print (name +&quot;:&quot; + say)MyFunction(name=&quot;小明&quot;,say=&quot;我是峡谷王者&quot;) # 关键指定实参 默认参数 1234def MyFunction(name=&quot;呵呵！&quot;): # 在定义函数时，给形参一个默认参数，可以再调用函数时有一个初始的默认值 print (name)MyFunction() 默认参数可以有效的避免用户在调用函数时，忘记输入参数所导致函数报错的问题 收集参数收集参数既是设置N个参数，形参可用(*name)表示，如果还有特定的参数，要使用关键字参数来设置，避免参数的混乱；还可使用默认参数来规避函数报错的风险； 为函数提供文档12345678910def my_print(input): &#x27;&#x27;&#x27;打印输入的参数 函数的文档、帮助 使用 print(函数名，_doc_) 查看 &#x27;&#x27;&#x27; input = &quot;打印&quot; + &quot;:&quot; + input return(input)print (my_print.__doc__) #查看这个函数的文档 函数与过程全局变量与局部变量根据定义变量的位置,变量的作用域有两种:局部变量：在函数内定义的变量包括参数，都被称为局部变量;全局比那辆：在函数外、全局范围内定义的变量，被称为全局变量;locals() 返回当前所在范围内的所有变量组成的”变量字典”globals() 该函数返回全局范围内搜索到的所有变量组成的”变量字典”var(object) 获取指定对象的范围内所变量组成的”变量字典”,如果不传入object参数,vars()和locals()的作用完全相同全局变量默认可以在所有函数内访问,如果在函数中定义与全局变量同名的变量,与此时就会发生局部变量遮蔽(hide)全局变量的情况 内嵌函数和闭包函数内部的变量不影响函数外面的变量，如果要使函数内定义的变量影响全局，使用global来定义这个函数即可 1234567a = 5def myfun(): global a a = 10 print(&quot;函数内的 a=&quot;,a)myfun()print (&quot;函数外的 a=&quot;,a) 如果不使用global定义a变量，外面的a变量就不会受到内部变量a的影响 内嵌函数(函数嵌套) 123456def fun1(name=&quot;&quot;): print(name + &quot;好饿啊！&quot;) def fun2(name=&quot;&quot;): print (name + &quot;好想吃手抓饼！&quot;) fun2(name)fun1(&quot;我&quot;) 多个函数的相互嵌套，用户只能调用最外面一层函数，函数内部的函数只能在其内部调用 12345678def fun1(): a = 5 def fun2(): nonlocal a a *= 10 print(a) fun2()fun1() 在多个函数嵌套定义时，有时候内部函数需要调用父集函数定义的变量，如果需要对这个变量进行改变时，函数就会报错；使用nolocal来强制这个变量为费局部变量可实现调用和修改该变量 lambdaPython写一些执行脚本时，使用lambda就可以剩下定义函数的过程，比如说我们只需要写个简单的脚本来管理服务器时间，我们就不需要专门定义一个函数然后再写调用，使用lambda就可以使得代码更加的精简。对于一些比较抽象并且整个程序执行下来只需要调用一两次的函数，有时候给函数起个名字也是比较头疼的问题，使用lambda就不再需要考虑函数命名的问题。简化代码的可读性，由于普通的屌丝函数阅读经常要跳到开头def定义部分,使用lambda函数可以省去这样的步骤。 1234567def fun1(a=3,b=2): c = a*b print (c)fun1()# lambda 写法g = lambda a=2,b=3: a*bg() filter和filter(条件,对象) filter方法用来过滤数据，可以根据条件过滤掉不想要的数据 1234temp = [0,2,55,123,1,4,55,67,558]def filt(a): return a%2print(list(filter(filt,temp))) 递归1234567def mdigui(num): a = num for i in range(1，num) a *= i print(a)mdigui(6) 123456789def mdigui(n=10): if n == 1: return 1 else: return n * mdigui(n-1)number = int(input(&quot;请输入一个正整数: &quot;))digui = mdigui(number)print(digui) 递归的正确实现需要满足两个条件，一个是调用函数自身，一个是正确设置自身的返回值; 阶乘OS模块OS：opreate systemos模块是paython的标准库中的一个用于访问操作系统功能的模块；使用os提供的接口可以实现跨平台的访问； os.sep 主要用于返回系统路径的分隔符(Windows系统是”\\“，Linux类系统如Ubuntu的分隔符是”/“，而MacOS系统是”:”os.name 返回当前工作的系统平台(如果是windows，返回”nt”，如果是linux返回”posix”)os.getevn(name) 获取系统的环境变量,name为环境变量名，返回环境变量名为name的环境变量值；os.getcwd() 返回当前运行脚本的工作路径 1os.getgwd() os.environ() 返回系统环境信息 os与系统目录操作os.listdir(path) 返回指定路径下所有文件和文件夹的名字 1os.listdir(path) # 列出path目录下所有的文件和文件夹列表 os.mkdir(name) 创建一个目录，只创建一个空的目录 1os.mkdir(path,chmod) # path为创建文件夹的完整路径地址 chmod可设置文件权限 linux下的文件权限 0o 7 7 7 八进制 所有者 所属组 其他人 权限划分: 可读 可写 可执行 4 2 1 os.rmdir(name) 删除一个空的目录，若目录中有文件则无法删除目录os.makedirs(dirname) 创建多层递归目录，如果目录存在，则创建目录失败os.removedirs(dirname) 删除多层递归空目录，如果目录中存在文件则无法删除os.chdir() 改变当前目录到制定的目录中 1os.chdir(path) # path为字符串文件目录地址 os.rename() 重命名目录或文件名，如果重命名的文件名对象已存在，则重命名失败 1os.removedirs(&#x27;Max-Man/vfx/clound/pyro/python/hda&#x27;) 判断os.path.exists(path) 判断文件或目录是否存在，存在返回True，否则返回Falseos.path.isfile(path) 判断是否为文件，是文件返回True，否则返回Falseos.path.isdir(path) 判断是否为目录，是目录返回True，否则返回False 文件路径os.path.join(path,name) 获得文件或文件名的绝对路径，path当前所在路径，name文件或目录的名字 12345678910import ospath = input()os.chdir(path) #移动工作路径到制定路径下taget = &quot;houdini18.5&quot;#print(os.getcwd())if os.path.exists(&quot;houdini18.5&quot;): #判断是否存在 fullPath = os.path.join(path,taget) #完整路径获取 print(fullPath)# 获取输入文件路径，将工作路径移动到获取的路径下，然后判断文件夹houdini18.5是否存在工作路径下，存在的话打印它的完整路径 面向对象类的定义了解类和对象两个重要的概念：类(class)和对象(object,也被称为实例，instance)类是某一批对象的抽象，可以把类理解成为某种概念; 有着某种相同性质的对象;对象，就是值某一个具体存在的事物。 怎么定义类方法： 1234class class_name: #class_name 为这个类的名字 # 执行语句 # 零个到多个变量 # 零个到多个方法(函数) 例: 1 类和方法(函数)不同，类不需要调用，定义即存在方法定义后需要用户再次调用，才会产生作用 类的作用创建对象调用构造器创建对象对象的作用： 操作对象的实例变量(包括访问实例变量的值、添加实例变量、删除实例变量) 操作对象的方法(包括调用方法、添加方法、删除方法) 1234567891011121314class Item(): def __init__(self,name=&quot;默认值&quot;,size=8): # 创建一个构造器，设置变量默认值 self.name = name # 创建构造器变量 self.size = sizeite1 = Item() # 实例化Item类，方便下面对类内的变量进行操作print(ite1.name) # 打印Item类下的name实例变量，对已经实例化的类可以直接访问其内部函数、方法和变量ite1.name=&quot;按钮&quot;print(ite1.name) # 也可以对实例化对象内的变量进行重新赋值print(ite1.size,ite1.name) # 访问多个值ite1.color = (250,250,250) # 为实例化对象添加一个新的实例化变量print(ite1.color) # 打印新添加的实例变量del ite1.color # 删除实例变量#print(ite1.color) 删除之后再打印就会提示 Item没有color属性 12345class Item: def print(self): print(&quot;打印方法&quot;)pr = Item() # 先实例化pr.print() # 实例化后就可以调用类里面定义的方法了 python的方法和实例变量是统一的：它们都是对象的成员。实例对象到底是方法还是实例变量，这取决你对它进行赋值时的是普通值还是函数值，是普通值则为变量，是函数则为方法 派生子类实例方法与绑定使用对象调用实例方法时，pthon通常会自动绑定第一个参数(通常建议将其参数命名为self)根据地一个参数出现的位置不同，第一个参数所绑定的对象略有区别在构造方法中引用该构造方法正在初始化的对象。在普通实例方法中引用调用该方法的对象。 1 使用对象调用实例方法时，self自动绑定实例方法返回self时，实例方法可以连续调用类调用实例方法时，self不会自动绑定，可以先实例化类，再将实例化对象传入到类调用实例方法的self中，以此来实现类调用方法; 类方法与静态方法類方法修飾符 @classmethod 12345678910111213class Tiger: # 類方法的兩個特點：a.用@classmethod修飾 b.定義一個cls形參(cls是class的縮寫) @classmethod def info(cls): print(&#x27;info 類方法&#x27;) print(cls)print(Tiger)# 類方法屬於類本身，所以用類調用# 類方法的第一個參數cls會自動綁定自身Tiger.info()t = Tiger()# 實例化對象調用類方法t.info() 靜態方法修飾符 @staticmethod 123456789101112 # 靜態方法的特點： a.定義行慘不是必須的 b.定義的形參也不會自動綁定 # 靜態方法相當與一個函數，類調用有參數的靜態方法必須傳入參數值class Tiger: @staticmethod def info(st): print(&#x27;info 靜態方法&#x27;) print(st)Tiger.info(&#x27;info&#x27;)# 類調用靜態方法時，如果方法有形參必須傳入參數# 對象調用靜態方法時，以爲參數傳入是必須的，所以也不會自動綁定t = Tiger()t.info(t) / 實例方法 類方法(@classmethod) 靜態方法(@staticmethod) 對象調用 自動綁定 自動綁定 不自動綁定 類調用 不自動綁定 自動綁定 不自動綁定 函數裝飾器12345678910111213141516# 作爲函數裝飾器使用的函數，它必須定義一個形參def foo(fn): print(&#x27;foo函數&#x27;) print(fn) return &#x27;acfun&#x27;# 使用函數來裝飾函數@foodef fun(): print(&#x27;函數&#x27;)# 此時函數fun已經使用foo函數來裝飾print(fun)&#x27;&#x27;&#x27;函數裝飾器的本質： a.將裝飾的函數作爲參數傳入到裝飾函數內 b.被裝飾的函數將被裝飾器函數修飾，返回的值是裝飾器函數的返回值&#x27;&#x27;&#x27; 類變量與實例變量類變量:在類空間或通過類引用和賦值的變量實例變量:通過對象引用或者self引用賦值的變量 123456789class User: # 在类空间中定义或赋值的变量叫做类变量 ff = &quot;name&quot; def __init__(self): # 通过self引用或赋值的变量叫做实例变量 self.name = &quot;name&quot; self.passwd = &quot;passwd&quot;# 通过类引用或赋值的变量，属于类变量User.type = &quot;other&quot; 合成屬性","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"},{"name":"30day","slug":"30day","permalink":"https://luomit.github.io/tags/30day/"}],"author":"luomit"},{"title":"Hexo博客搭建","slug":"博客/Hexo博客搭建","date":"2020-02-09T15:22:59.000Z","updated":"2021-05-12T09:41:20.553Z","comments":true,"path":"2020/02/09/博客/Hexo博客搭建/","link":"","permalink":"https://luomit.github.io/2020/02/09/%E5%8D%9A%E5%AE%A2/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"准备Node.js安装windowsnode.js链接 https://nodejs.org/en/ node.js安装会给系统安装一个npm的包管理器，这是hexo搭建博客所需要的；linux下载源码包，然后解压到任意文件夹 123456sudo cp node-v12.16.2-linux-x64 /opt/cd /opt/node-v12.16.2-linux-x64/bin/sudo ln -s node /usr/bin/nodesudo ln -s npm /usr/bin/npmnode -vnpm -v 执行上面的代码进行软连接打开终端获取管理员权限windows使用管理员身份运行命令提示符窗口liunx or mac则使用sudo su获得管理员权限查看node版本 1node -v 查看npm版本 1npm -v git安装git https://git-scm.com/ Hexo安装 使用npm安装cnpm来提高构建博客框架时下载文件的速度的1npm install -g cnpm --registry=https://registry.npm.taobao.org linux在linux执行完上一步骤后可能使用cnpm会返回1234567Command &#x27;cnpm&#x27; not found, did you mean: command &#x27;npm&#x27; from deb npm (6.14.4+ds-1ubuntu2) command &#x27;cypm&#x27; from deb pakcs (2.2.0-1) command &#x27;cpm&#x27; from deb cpm (0.32-1.2build2) command &#x27;cxpm&#x27; from deb xpmutils (1:3.5.12-1)Try: sudo apt install &lt;deb name&gt; 是因为这样安装他的软链接不会指向/usr/bin/目录，你需要返回查看cnpm安装时返回的代码如下123/opt/node-v12.16.2-linux-x64/bin/cnpm -&gt; /opt/node-v12.16.2-linux-x64/lib/node_modules/cnpm/bin/cnpm+ cnpm@6.1.1added 685 packages from 953 contributors in 14.043s 然后手动创建软连接,之后再执行cnpm就可以使用了1sudo ln -s /opt/node-v12.16.2-linux-x64/bin/cnpm /usr/bin/cnpm 使用cnpm安装hexo1cnpm install -g hexo 按照上面的方法手动创建软连接1sudo ln -s /opt/node-v12.16.2-linux-x64/bin/hexo /usr/bin/hexo 搭建 pwd 返回当前终端所在系统位置 mkdir ‘文件夹名’ 创建一个博客文件目录，后续的配置都在这个目录内进行 hexo init 初始化博客框架初始化报错1npm install -g cnpm --registry=https://registry.npm.taobao.org 123456789101112ls -l#total 261#-rw-r--r-- 1 Administrator 197121 2465 2月 10 01:49 _config.yml#-rw-r--r-- 1 Administrator 197121 71577 2月 10 01:49 db.json#drwxr-xr-x 1 Administrator 197121 0 2月 10 01:13 node_modules/#-rw-r--r-- 1 Administrator 197121 581 2月 10 01:35 package.json#-rw-r--r-- 1 Administrator 197121 133002 2月 10 01:13 package-lock.json#drwxr-xr-x 1 Administrator 197121 0 2月 10 01:49 public/#drwxr-xr-x 1 Administrator 197121 0 2月 10 01:02 scaffolds/#drwxr-xr-x 1 Administrator 197121 0 2月 10 01:02 source/#drwxr-xr-x 1 Administrator 197121 0 2月 10 01:46 themes/## 可以列出当前目录下的hexo创建的所有文件windows使用dir来查看 1234hexo start#INFO Start processing#INFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.## 本地运行博客网页可使用hexo s 123hexo n &quot;博客文章名&quot;#INFO Created:&quot;文章路径&quot; ## 创建一篇新的博客文章 12hexo clean ## 删除静态博客 12hexo generate ## 生成静态博客 hexo g 部署GitHub and Coding仓库的创建与本地文件配置在GitHub创建一个名字格式为 “用户名”+ .github.io 的仓库在Coding创建一个名字格式为 “用户名”+ .coding.me 的仓库然后复制仓库路径添加到博客目录下_config.yml内，如下所示12345678910# Deployment# Docs: https://hexo.io/docs/deployment.htmldeploy:- type: &#x27;git&#x27; repo: &#x27;仓库地址&#x27; branch: &#x27;分支&#x27;- type: &#x27;git&#x27; repo: git@e.coding.net:luomit/luomit.coding.me.git branch: master## 这里可以配置多个仓库的路径一键部署到多个仓库下 git 安装在博客根目录下使用以下命令安装git1cnpm install --save hexo-deployer-git git 用户配置12345# git config --global user.name &quot;用户名&quot;# git config --global user.email &quot;邮箱&quot;git config --global user.name luomitgit config --global user.email 1107199736@qq.com## 注意，如果需要在部署时同时部署到不同的站点，则这些站点的用户名和注册邮箱需要一致 配置ssh密钥 检查ssh密钥是否存在cd 到系统根目录，使用ls -l 列出所有文件，如果有.ssh文件夹存在，则打开.pud结尾的文件将密钥复制到远端站点的用户设置内 生成SSH密钥123ssh-keygen -t rsa -C &quot;your_email@example.com&quot;## 使用以上代码会生成一个.ssh的文件夹在系统根目录内，.ssh文件夹内就有id_rsa和id_rsa.pub两个文件，分别表示生成的私钥和公钥## 公钥一定要妥善保管，切勿泄露他人，以免心怀不轨的人偷走你的&#x27;小姐姐&#x27;or&#x27;小哥哥&#x27; 部署到远端仓库12345678910$ hexo clean ## 删除静态博客$ hexo generate ## 生成静态博客$ hexo deploy## 部署$ hexo backup## 备份$ hexo clean &amp;&amp; hexo generate &amp;&amp; hexo backup &amp;&amp; hexo deploy## 也可以一次执行全部命令 主题替换Hexo主题官网12git clone https://github.com/JoeyBling/hexo-theme-yilia-plus.git /themes/yilia## git clone &quot;主题仓库路径&quot; &quot;目标路径&quot; Sakura主题修改Hexo 插件Hexo-tag-gdemo用于展示代码在终端输入的过程，详情基本样式：123&gt; &#123;% gdemo_terminal &#x27;node ./demo&#x27; &#x27;250px&#x27; &#x27;bash&#x27; &#x27;500&#x27; &#x27;$&#x27; &#x27;demo-teriminal&#x27; %&#125;Hello World!&#123;% endgdemo_terminal %&#125; Fancybox(主题集成)点击图片预览时可以缩放等，详情基本样式：(在博客中插入)1234567#第一种&#123;% fb_img src [caption] %&#125;#第二种&lt;a href=&quot;image.jpg&quot; data-fancybox=&quot;images&quot; data-caption=&quot;My caption&quot;&gt; &lt;img src=&quot;thumbnail.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;#更多部分多方法，详情跳转 hexo-tag-bili(主题集成)用来在文章或单页面中插入B站外链视频，详情1&#123;% bili video_id [page] %&#125; Bilibili追番npm安装配置说明说明12&gt;&gt;&gt; hexo bangumi -u #更新追番数据&gt;&gt;&gt; hexo bangumi -d #删除追番数据 豆瓣书单Github安装配置说明地址1&gt;&gt;&gt; hexo douban -bgm 图标设置插件fontawesomeHexo文章隐藏插件[参考][7]windows下端口占用问题在windows下时常会遇到端口占用而导致hexo不能在本地运行博客预览，如当4000端口占用可使用”netstat -ano | findstr 4000”，查看当前占用4000端口的pid然后使用”tasklist | findstr pid”查询当前占用该端口的程序，使用”taskkill -PID 10388 -F”来杀死该程序，如下所示1234567891011C:\\Users\\Administrator&gt;netstat -ano | findstr 4000 TCP 0.0.0.0:4000 0.0.0.0:0 LISTENING 10388 TCP [::]:4000 [::]:0 LISTENING 10388C:\\Users\\Administrator&gt;tasklist | findstr 10388node.exe 10388 Console 1 62,568 KC:\\Users\\Administrator&gt;taskkill -PID 10388 -F成功: 已终止 PID 为 10388 的进程。C:\\Users\\Administrator&gt; git 常见问题与解决方法问题：本地仓库与远程仓库不同步导致报错1234567To github.com:luomit/luomit.github.io.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to &#x27;git@github.com:luomit/luomit.github.io.git&#x27;```解决方案：```bushgit pull origin master --allow-unrelated-histories 主题帮助文档挺详细","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://luomit.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://luomit.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"搭建","slug":"搭建","permalink":"https://luomit.github.io/tags/%E6%90%AD%E5%BB%BA/"}],"author":"luomit"},{"title":"Hugo博客搭建","slug":"博客/Hugo博客搭建","date":"2020-02-09T15:15:45.000Z","updated":"2021-05-12T09:41:19.641Z","comments":true,"path":"2020/02/09/博客/Hugo博客搭建/","link":"","permalink":"https://luomit.github.io/2020/02/09/%E5%8D%9A%E5%AE%A2/Hugo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"搭建Hugo的安装Hugo帮助文档Hugo下载链接Go下载链接Mercurial下载链接 检查hugo版本 1hugo version 站点的创建123hugo new site wiki #创建一个文件夹名字为wiki的站点cd wiki git init #初始化站点 配置添加主题12git submodule add https://github.com/forestryio/hugo-theme-novela.git themes/novela #下载novela主题到/themes/novela文件夹下 本地运行博客12hugo server -t nederburg --buildDrafts# hugo server -t &quot;主题名&quot; --buildDrafts 创建博客文章12hugo new post/Hogo博客搭建.md#hugo new post /&quot;博客名.md&quot; 部署生成public仓库1hugo --theme=novela -- baseUrl=&quot;https://luomit.github.io&quot; --buildDrafts 提交部署123456cd publicgit init git add .git commit -m &quot;第一次提交&quot;git remote add origin https://github.com/luomit/luomit.github.io.gitgit push -u origin master 未完待续…..","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"hugo","slug":"hugo","permalink":"https://luomit.github.io/tags/hugo/"}],"author":"luomit"},{"title":"Website favorites","slug":"资源/Website favorites","date":"2019-10-23T00:51:04.000Z","updated":"2021-05-12T09:35:44.585Z","comments":true,"path":"2019/10/23/资源/Website favorites/","link":"","permalink":"https://luomit.github.io/2019/10/23/%E8%B5%84%E6%BA%90/Website%20favorites/","excerpt":"","text":"CGTalk外网CG交流论坛 Artstation客栈艺术家栖息地 扫描模型下载高精度扫描模型免费下载 cgmeetup国外CG艺术社区 500px视觉中国摄影作品分享社区 pexels外网高清图片需要黑魔法 pixabay需要黑魔法 textures每日免费限制每天十张免费高清贴图，需要黑魔法 Pixiv二次元站优秀二次元绘画鉴赏 AboutCG国内最正规最权威的CG教育社区 vfxforce国外优质CG特效资讯与教程分享 VFXinfo丰富的CG导航网站 NewvfxCG交流、文档查阅 HoudiniWiKi经典教程，全是干货 YouTube视频下载复制视频连接粘贴，然后在刷新的页面选中要下载的分辨率，然后右键另存视频即可。 YouTube字幕下载粘贴视频连接，生成并下载字幕文件 Film resource network高清电影资源下载 Markdown博客书写编辑器 Age动漫资源最新动漫资源下载 宅次元站你要的这里全有 CSDN我的csdn地址 CSDN编辑器CSDN博客书写超级好用 Everypixel Freephotos librestock Stock Up Findaphoto Stockio wallpaperhub高清大气简约的免费壁纸","categories":[{"name":"links","slug":"links","permalink":"https://luomit.github.io/categories/links/"}],"tags":[{"name":"网站","slug":"网站","permalink":"https://luomit.github.io/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"常用VEX","slug":"筆記/houdini/常用VEX","date":"2019-10-23T00:51:04.000Z","updated":"2021-05-12T09:39:41.445Z","comments":true,"path":"2019/10/23/筆記/houdini/常用VEX/","link":"","permalink":"https://luomit.github.io/2019/10/23/%E7%AD%86%E8%A8%98/houdini/%E5%B8%B8%E7%94%A8VEX/","excerpt":"","text":"findattribval 找同类findattribval用来查找指定层级(vertices、point、prim)上属性是否相同，相同则返回0，否则返回-1；然后再调取相同时的对象的某些属性来进行其他的操作。示例： 12int result = findattribval(1,&quot;point&quot;,&quot;name&quot;,s@name,0);v@v = point(1,&quot;v&quot;,result); 如在刚体中查找对比0和1两个输入端刚体的那么属性，如果左右相同，则将1号对象上相同name的元素的某个属性赋予到0号对象对应元素上； addvariablename 自定义全局变量addvariablename在属性调用过程中，有时候使用全局变量的方式会非常的方便；这时候我们可以使用这个方法将自定义属性定义为一个houdini的全局变量来调用； 123float a = @numpt%2；f@b = a；addvariablename(0,&quot;b&quot;,&quot;B&quot;)； addvariablename(数据端口，属性，全局变量名)； 未完…","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"vex","slug":"vex","permalink":"https://luomit.github.io/tags/vex/"}],"author":"luomit"},{"title":"Ubuntu安装配置Pycharm","slug":"筆記/linux/Ubuntu配置Pycharm","date":"2019-10-01T00:51:04.000Z","updated":"2021-05-12T09:41:31.347Z","comments":true,"path":"2019/10/01/筆記/linux/Ubuntu配置Pycharm/","link":"","permalink":"https://luomit.github.io/2019/10/01/%E7%AD%86%E8%A8%98/linux/Ubuntu%E9%85%8D%E7%BD%AEPycharm/","excerpt":"","text":"下载安装下载PyCharm Ubuntu可以直接在终端执行以下代码进行安装： 1sudo snap install [pycharm-professional | pycharm-community] --classic 如果使用代码安装失败，可以使用上面的链接下载对应的PyCharm版本，如”pycharm-professional-2019.2.3.tar.gz”;然后将”pycharm-professional-2019.2.3.tar.gz”解压到 /opt 路径下 然后打开终端 12cd /opt/pycharm-2019.2.3/bin./pycharm.sh 激活然后就是一顿设置，最后输入激活码时，将下面的激活码复制进去就可以了 1MTW881U3Z5-eyJsaWNlbnNlSWQiOiJNVFc4ODFVM1o1IiwibGljZW5zZWVOYW1lIjoiTnNzIEltIiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTktMTEtMDYifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAxOS0xMS0wNiJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjAxOS0xMS0wNiJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE5LTExLTA2In0seyJjb2RlIjoiR08iLCJwYWlkVXBUbyI6IjIwMTktMTEtMDYifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOS0xMS0wNiJ9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDE5LTExLTA2In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE5LTExLTA2In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMDYifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjAxOS0xMS0wNiJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE5LTExLTA2In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTktMTEtMDYifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOS0xMS0wNiJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE5LTExLTA2In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTktMTEtMDYifSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMTktMTEtMDYifV0sImhhc2giOiIxMDgyODE0Ni8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-aKyalfjUfiV5UXfhaMGgOqrMzTYy2rnsmobL47k8tTpR/jvG6HeL3FxxleetI+W+Anw3ZSe8QAMsSxqVS4podwlQgIe7f+3w7zyAT1j8HMVlfl2h96KzygdGpDSbwTbwOkJ6/5TQOPgAP86mkaSiM97KgvkZV/2nXQHRz1yhm+MT+OsioTwxDhd/22sSGq6KuIztZ03UvSciEmyrPdl2ueJw1WuT9YmFjdtTm9G7LuXvCM6eav+BgCRm+wwtUeDfoQqigbp0t6FQgkdQrcjoWvLSB0IUgp/f4qGf254fA7lXskT2VCFdDvi0jgxLyMVct1cKnPdM6fkHnbdSXKYDWw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow== 配置 最后是设置PyChram的启动图标使用文本编辑器新建一个名字为PyChram.desktop的文件内容为 123456[Desktop Entry]Name = PyCharmType = ApplicationExec = /opt/pycharm-2019.2.3/bin/pycharm.sh #pycharm.sh文件的绝对路径，一般就在软件安装目录bin文件夹下Icon = /opt/pycharm-2019.2.3/bin/pycharm.svg #图标图片文件路径Terminal = False 现将PyChram.desktop保存在桌面上，然后使用 1sudo cp PyChram.desktop /usr/share/applications 完成PyCharm的安装激活 。。。","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"pchram","slug":"pchram","permalink":"https://luomit.github.io/tags/pchram/"}],"author":"luomit"},{"title":"Python在HDA中使用","slug":"筆記/python/Python在HDA中使用","date":"2019-09-05T00:51:04.000Z","updated":"2021-05-12T09:41:24.984Z","comments":true,"path":"2019/09/05/筆記/python/Python在HDA中使用/","link":"","permalink":"https://luomit.github.io/2019/09/05/%E7%AD%86%E8%A8%98/python/Python%E5%9C%A8HDA%E4%B8%AD%E4%BD%BF%E7%94%A8/","excerpt":"","text":"Event Handler在HDA中，要创建Python脚本，需要先选择一个事件处理器(EventHandle),他表示你要在什么时候执行你现在所创建的脚本命令 On Created (在节点创建时，执行脚本) 如选择此项编辑Python脚本，Python将会在节点创建时执行Python中的命令 Python Model (Python模式) 这一项会使创建的脚本在使用过程中根据用户设置执行 可以使用这一项给节点设置参数提示等功能 On Delete(在节点创建时执行脚本) Python在Houdini节点上的常用方法 Set Color 设置颜色 123node = kwargs[&#x27;node&#x27;] #获取当前节点context = hou.pwd() #当前节点的父对象node.setColor(hou.Color((0.584,0.776,1))) #设置当前节点颜色 Node 创建节点 123456try: out = context.createNode(&#x27;null&#x27;,&#x27;OUT_render&#x27;) #从当前节点的父对象创建节点 out.setInput(0,node) #设置out节点输入端为当前节点node out.setColor(hou.Color(0,0,0)) #设置out节点的颜色except: pass Print and Button feedback 打印字符和按钮反馈 1234567891011121314151617def CacheGeo(): #在OnCreate创建一些自定的方法，然后可以在节点参数中调用 this = hou.pwd() #获取当前节点 print &quot;\\nCaching......!&quot; filecache = hou.node(this.path() + &#x27;/cache_geo&#x27;) #获取设置当前节点内cache_geo的路径为filecache filecache.parm(&#x27;execute&#x27;).pressButton() #获取filecache节点上execute的状态 this.setColor(hou.Color((0.584,0.776,1))) #设置节点颜色 def ReloadGeo(): this = hou.pwd() print &quot;\\nLoaded successfully&quot; filecache = hou.node(this.path() + &#x27;/report_geo&#x27;) filecache.parm(&#x27;reload&#x27;).pressButton() this.setColor(hou.Color((0.475,0.812,0.204))) output = hou.node(this.path() + &#x27;/output0&#x27;) #设置当前节点内output0节点的路径为output geo = output.geometry() #获取output的geometry并赋予到geo(要求出geometry才可以求这个节点上的geometry属性) print len(geo.points()) #打印geo的点数 设置这两个按钮(cache_geo、report_geo)执行时调用不同的方法，执行不同的操作 参数调用PythonScripts 1hou.pwd().hdaModule().CacheGeo() Download CameraBack and FileIO HDA","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"}],"author":"luomit"},{"title":"Houdini流体水花I","slug":"筆記/houdini/HoudiniFlip","date":"2019-09-03T00:51:04.000Z","updated":"2021-05-12T09:41:33.930Z","comments":true,"path":"2019/09/03/筆記/houdini/HoudiniFlip/","link":"","permalink":"https://luomit.github.io/2019/09/03/%E7%AD%86%E8%A8%98/houdini/HoudiniFlip/","excerpt":"","text":"Flip的大体结构 fliptank_initial wavetank 用于设置水池的初始大小、位置、粒子间距以及其他一些动力学属性 BoundaryLayer边界层：用于限制流体运动的边界，将位于边界的流体运动状态减弱，方便后期将流体嵌入到更大的流体系统中 ，又可称其为边界缓冲层 Narrow Band 这是一种流体结算的一种类型 特点：只在流体的表面生成一层粒子用于flip结算，这样大大节省了流体模拟对计算机内存的消耗；但是这样只并不会减少对结算的时间。 Narrow Band FLIP视频介绍要使用这种方式创建并模拟Flip需要在创建水箱(OceanSource)时将Particle下的Narrow Band Particle启用(图一)，并且在Dop的Flip Object中(图二)设置Input Type为NarrowBand才可以 DopNetwork flipsolver Narrow Band 默认情况与flipObject关联，Bandwidth控制粒子层的厚度，Attribute-Field Pairs则可以将粒子上的属性转移到Field(场)中，避免属性的丢失； ParticleMotion-Reseeding 控制粒子再运动时的分布，在粒子分布较多的地方杀掉部分，在粒子稀疏的地方后新增一些以达到粒子在流体表面的平衡状态 ParticleMotion-Vorticity 流体涡旋，在启用流体的涡旋时，能够增加流体模拟的真实度 ParticleMotion-Rest VolumeMotion-VelosityTransfer这个就是表面粒子运动和底层网格之间相互传递速度属性(指定用于在每一帧结算之前将粒子的速度传递到底层网格，然后返回粒子的方法)。FlipSolverahHelp collisionsource 用于将polygons对象转为VDB碰撞对象，可以对碰撞网格精度VoxelSize调节，还可以设置碰撞速度的计算Geometry下的Velocity； 通过设置碰撞对象的速度属性可以影响产生碰撞时所受碰撞的力度大小； 如果在collisionsource之前已经设置好了碰撞物体的速度，开启这里的Velocity时collisionsource会 重新根据物体的运动状态来计算速度属性覆盖原有的属性 Fluid Mesh在流体制作中，将流体粒子转换成mesh模型才可以给fluid赋予材质进行渲染；并且水的形态细节最终也是由这一步决定； particlefluid mesh流程 流体粒子转mesh，首先需要将particle转为vdb，然后对vdb进行膨胀操作，再将膨胀后的vdb进行smooth，最后对vdb进行收缩；(particle to mesh 的大概流程) 在Houdini中使用particlefluidsurface节点来调节和实现particlefluid mesh的所有操作 在实际制作particlefulid mesh时，会出现上图的情况，由于以上的操作默认是对整体粒子做相同操作且强度相同，这就导致粒子在高速飞溅的部分完全的smooth掉了，丢失掉水的细节；这是我们需要根据某种属性mask来控制mesh的范围强度，从而保留更多的模拟细节。 最后通过优化polymesh拓扑节省mesh对内存的占用 fluid mesh 实践技巧 复制两个particlefluidsurface节点，用作mesh调节的参考(如果对原始的粒子量做调整，每次计算需要耗费大量的时间，所以对particlefluidsurface做一定的裁切，调节出合适的mesh参数后再应用的原始的particlefluidsurface上就可以节省大量的时间，提升工作效率) 上图红色部分纠正’无线’应为’无限’ 使用Regions的BoundingBox对水箱进行裁切，尽量保留既有运动剧烈的流体粒子，有保留相对运动平缓的粒子，这样在mesh时有个参考比较 .font1{text-align:center;color:#D2691E} 初学Flip笔记，希望大家给点评论，指出错误和不足. **\\\\ ( >O< ) / **","categories":[],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"flip","slug":"flip","permalink":"https://luomit.github.io/tags/flip/"}],"author":"luomit"},{"title":"Houdini 粒子渲染拖尾 I","slug":"筆記/houdini/Houdini粒子拖尾 Ⅰ","date":"2019-09-01T00:51:04.000Z","updated":"2021-05-12T09:41:37.035Z","comments":true,"path":"2019/09/01/筆記/houdini/Houdini粒子拖尾 Ⅰ/","link":"","permalink":"https://luomit.github.io/2019/09/01/%E7%AD%86%E8%A8%98/houdini/Houdini%E7%B2%92%E5%AD%90%E6%8B%96%E5%B0%BE%20%E2%85%A0/","excerpt":"","text":"实现路径运动节点网络 节点概述 创建一个不规则的发射源用于发射粒子，不规则的形状可以使粒子在发射开始时便获得一个随机的初始位置； 以粒子发射源位置为起点绘制创建一条曲线(曲线间点和点的位置均分布，不宜过于靠近，否则力会相互间影响)，计算线的切线向量，并转为速度场； 在粒子系统中使用popadvectbyvolume将速度场引入**(重点：advection type 平流类型使用Update velocity)**，Velocity Blend 速度混合为1，让引入的速度场完全影响粒子； 通过控制速度场来获得粒子在跟随路径运动过程中飘散出来的效果； （重点：粒子在结束模拟之前不允许有粒子死亡，也就是粒子的寿命需要给一个足够高的值来确保在结束模拟时没有粒子死亡） 拖尾的渲染要点和设置要实现粒子在摄像机空间位移路径模糊的需要注意以下几点： 粒子不能是缓存在磁盘上的粒子，不需使用pop解算完成，暂时缓存在内存上的粒子； 需要创建一套粒子数量恒定不变的粒子系统来替换模拟好的动态； 1234567if(i@id &#x3D; point(1,&quot;id&quot;,i@id))&#123; v@P &#x3D; point(1,&quot;P&quot;,i@id);&#125;f@age &#x3D; point(1,&quot;age&quot;,i@id);f@life &#x3D; point(1,&quot;life&quot;,i@id);#根据id来匹配位置、生命&#x2F;寿命、年龄等需要的属性 在节点属性上不要启用几何体运动动属性 提高渲染相机上的ShutterTime值 Mantra渲染器使用PBR渲染引擎，然后提高XformTimeSamples、GeoTimeSamples来得到模糊效果 在Mantra渲染器的Sampling里，需要将PixelSamples提高到20左右才可以得到较清晰的运动模糊 关于替换粒子未来避免麻烦，我将教程中的步骤简化制作了一个HDA，方便日后制作时调用 12345678910111213141516171819vector rest &#x3D; point(2,&quot;P&quot;,0);int pt &#x3D; addpoint(0,rest);setpointattrib(0,&quot;id&quot;,pt,0,&quot;set&quot;);setpointattrib(0,&quot;rest&quot;,pt,rest,&quot;set&quot;);int off &#x3D; chi(&quot;on_off&quot;);int num &#x3D; detail(1,&quot;nextid&quot;,0);int ptnum &#x3D; num*off + chi(&quot;point_constant&quot;)*off + num*(chf(&quot;point_multi&quot;)*(1-off));&#x2F;&#x2F;printf(&quot;%d\\n&quot;,ptnum);&#x2F;&#x2F;setpointattrib(0,&quot;ptnum&quot;,pt,ptnum,&quot;set&quot;);for (int i &#x3D; 0; i &lt; ptnum-1; ++i)&#123; &#x2F;* code *&#x2F; int a &#x3D; addpoint(0,rest); setpointattrib(0,&quot;id&quot;,a,i+1,&quot;set&quot;); setpointattrib(0,&quot;rest&quot;,a,rest,&quot;set&quot;);&#125;#创建恒定粒子数的粒子系统 123456789101112if(i@id &#x3D; point(1,&quot;id&quot;,i@ptnum))&#123; v@P &#x3D; point(1,&quot;P&quot;,i@id);&#125;f@age &#x3D; point(1,&quot;age&quot;,i@id);f@life &#x3D; point(1,&quot;life&quot;,i@id);if(@P &#x3D;&#x3D; @rest)&#123; f@Alpha &#x3D; 0;&#125; #根据id传递需要保留的粒子属性 关于粒子死亡因为粒子的整个过程需要保持粒子量的恒定不变，所以粒子会一直存在，需要通过控制粒子的Alpha的使粒子消失这就使用到age和life这两个属性了。 12345678f@Alpha &#x3D; 1.0;f@pscale &#x3D; fit01(rand(@id),chf(&quot;min&quot;),chf(&quot;max&quot;));v@Cd &#x3D; chramp(&quot;Cd&quot;,@age&#x2F;(@life+rand(@id)*5));f@Alpha &#x3D; chramp(&quot;Alpha&quot;,@age&#x2F;@life);#设置Alpha粒子的透明 总结这种方式可以快速得到很棒的粒子曲线模糊的效果，但是也存在很大局限性；比如我感觉最麻烦的就是不能读取磁盘粒子来实现，这在模拟大量粒子时就需要机器拥有足够的内存来存储这些粒子，否则无法实现；如果需要对存盘粒子进行缓存建议阅读大象小牛的相关文章，他有讲到这种方式的实现；总之第一种方式出来的效果更加完美，第二种则更加实用； 以上均为个人学习理解的观点笔记，仅供参考；不足之处还望评论指出！！","categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"}],"tags":[{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"trail","slug":"trail","permalink":"https://luomit.github.io/tags/trail/"},{"name":"particle","slug":"particle","permalink":"https://luomit.github.io/tags/particle/"}],"author":"luomit"}],"categories":[{"name":"notes","slug":"notes","permalink":"https://luomit.github.io/categories/notes/"},{"name":"links","slug":"links","permalink":"https://luomit.github.io/categories/links/"}],"tags":[{"name":"ue4","slug":"ue4","permalink":"https://luomit.github.io/tags/ue4/"},{"name":"shader","slug":"shader","permalink":"https://luomit.github.io/tags/shader/"},{"name":"地编","slug":"地编","permalink":"https://luomit.github.io/tags/%E5%9C%B0%E7%BC%96/"},{"name":"材质","slug":"材质","permalink":"https://luomit.github.io/tags/%E6%9D%90%E8%B4%A8/"},{"name":"vfx","slug":"vfx","permalink":"https://luomit.github.io/tags/vfx/"},{"name":"特效","slug":"特效","permalink":"https://luomit.github.io/tags/%E7%89%B9%E6%95%88/"},{"name":"cache","slug":"cache","permalink":"https://luomit.github.io/tags/cache/"},{"name":"迁移","slug":"迁移","permalink":"https://luomit.github.io/tags/%E8%BF%81%E7%A7%BB/"},{"name":"缓存","slug":"缓存","permalink":"https://luomit.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"houdini","slug":"houdini","permalink":"https://luomit.github.io/tags/houdini/"},{"name":"四元数","slug":"四元数","permalink":"https://luomit.github.io/tags/%E5%9B%9B%E5%85%83%E6%95%B0/"},{"name":"教程","slug":"教程","permalink":"https://luomit.github.io/tags/%E6%95%99%E7%A8%8B/"},{"name":"Houdini","slug":"Houdini","permalink":"https://luomit.github.io/tags/Houdini/"},{"name":"trail","slug":"trail","permalink":"https://luomit.github.io/tags/trail/"},{"name":"particle","slug":"particle","permalink":"https://luomit.github.io/tags/particle/"},{"name":"Arch","slug":"Arch","permalink":"https://luomit.github.io/tags/Arch/"},{"name":"i3","slug":"i3","permalink":"https://luomit.github.io/tags/i3/"},{"name":"安装","slug":"安装","permalink":"https://luomit.github.io/tags/%E5%AE%89%E8%A3%85/"},{"name":"linux","slug":"linux","permalink":"https://luomit.github.io/tags/linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://luomit.github.io/tags/Ubuntu/"},{"name":"壁纸","slug":"壁纸","permalink":"https://luomit.github.io/tags/%E5%A3%81%E7%BA%B8/"},{"name":"Manjaro","slug":"Manjaro","permalink":"https://luomit.github.io/tags/Manjaro/"},{"name":"shell","slug":"shell","permalink":"https://luomit.github.io/tags/shell/"},{"name":"vim","slug":"vim","permalink":"https://luomit.github.io/tags/vim/"},{"name":"neovim","slug":"neovim","permalink":"https://luomit.github.io/tags/neovim/"},{"name":"sublime text","slug":"sublime-text","permalink":"https://luomit.github.io/tags/sublime-text/"},{"name":"vscode","slug":"vscode","permalink":"https://luomit.github.io/tags/vscode/"},{"name":"python","slug":"python","permalink":"https://luomit.github.io/tags/python/"},{"name":"opencolorio","slug":"opencolorio","permalink":"https://luomit.github.io/tags/opencolorio/"},{"name":"color","slug":"color","permalink":"https://luomit.github.io/tags/color/"},{"name":"project","slug":"project","permalink":"https://luomit.github.io/tags/project/"},{"name":"manage","slug":"manage","permalink":"https://luomit.github.io/tags/manage/"},{"name":"usd","slug":"usd","permalink":"https://luomit.github.io/tags/usd/"},{"name":"Solaris","slug":"Solaris","permalink":"https://luomit.github.io/tags/Solaris/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://luomit.github.io/tags/ubuntu/"},{"name":"nuke","slug":"nuke","permalink":"https://luomit.github.io/tags/nuke/"},{"name":"function","slug":"function","permalink":"https://luomit.github.io/tags/function/"},{"name":"PyQt5","slug":"PyQt5","permalink":"https://luomit.github.io/tags/PyQt5/"},{"name":"30day","slug":"30day","permalink":"https://luomit.github.io/tags/30day/"},{"name":"hexo","slug":"hexo","permalink":"https://luomit.github.io/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://luomit.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"搭建","slug":"搭建","permalink":"https://luomit.github.io/tags/%E6%90%AD%E5%BB%BA/"},{"name":"hugo","slug":"hugo","permalink":"https://luomit.github.io/tags/hugo/"},{"name":"网站","slug":"网站","permalink":"https://luomit.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"vex","slug":"vex","permalink":"https://luomit.github.io/tags/vex/"},{"name":"pchram","slug":"pchram","permalink":"https://luomit.github.io/tags/pchram/"},{"name":"flip","slug":"flip","permalink":"https://luomit.github.io/tags/flip/"}]}